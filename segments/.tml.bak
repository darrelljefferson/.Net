# <title>Tcl procedures for the /segment directory</title>

# include the "home" package needed for the home page
#package_require_local segments /segments/segments.tcl

package provide segments 1.0 
namespace eval segments {}

proc segments::appendtable { tablename } {
	set tablename [string tolower $tablename]
	
	# see if the table has already been added
	if {[string first $tablename [ncgi::value subsets_.ClauseFrom_]] == -1} {
		# if need to add it:
		# 1) add table name to the From clause
		if {[string trim [ncgi::value subsets_.ClauseFrom_]] == ""} {
			ncgi::setValue subsets_.ClauseFrom_ "$tablename"
		} else {
			ncgi::setValue subsets_.ClauseFrom_ "[ncgi::value subsets_.ClauseFrom_], \n$tablename"
		}
		
		# 2) add the join criteria to the where clause
		if {$tablename == "clicktracking_"} {
			set joinclause "([dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_) AND" 
		} elseif {$tablename == "clickstreamdata_"} {
			set joinclause "(clicktracking_.ClickID_=clickstreamdata_.ClickID_) AND"
		} else {
			set joinclause ""
		}
		ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$joinclause"
	}
}

proc segments::clickstreamdata_amountcompare {calculation whereclause comparevalue compareoperator indexname} {
        # if indexname is empty, we don't hint.  otherwise we hint to use the index specified by indexname
        set fullclause "(SELECT "
        if {$indexname != "" && [dbinfo::is_oracle]} {
            append fullclause "/*+ INDEX(clicktracking_ $indexname) */ "
        }
        # If we are comparing equal to zero, then we will convert nulls to zero.  This is so that we
        # can do something like find everybody who never bought anything.  However, we deliberately do not
        # convert nulls to zero if they are finding everybody who bought less than $100 worth of stuff because
        # they probably still only want people who bought something.  For marketing purposes, there is a
        # very big difference between somebody who bought a little bit and somebody who never bought anything.
        if {$comparevalue == "0" && $compareoperator == "="} {
            set nulltozero 1
        } else {
            set nulltozero 0
        }
        if {$nulltozero == 1} {
            if {[dbinfo::is_mssql]} {
                append fullclause "ISNULL("
            } elseif {[dbinfo::is_oracle]} {
                append fullclause "NVL("
            } else {
                # default behavior is for postgres
                append fullclause "COALESCE("
            }
        }
        append fullclause "$calculation"
        if {$nulltozero == 1} {
            append fullclause ",0)"
        }
        append fullclause " FROM clicktracking_"
        if {$indexname != "" && [dbinfo::is_mssql]} {
            append fullclause " WITH (INDEX = $indexname)"
        }
        append fullclause ", clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_ $whereclause) $compareoperator $comparevalue"
        return $fullclause
}

proc segments::clickstreamdata_exists {whereclause indexname} {
        # if indexname is empty, we don't hint.  otherwise we hint to use the index specified by indexname
        set fullclause "EXISTS (SELECT "
        if {$indexname != "" && [dbinfo::is_oracle]} {
            append fullclause "/*+ INDEX(clicktracking_ $indexname) */ "
        }
        append fullclause "NULL FROM clicktracking_"
        if {$indexname != "" && [dbinfo::is_mssql]} {
            append fullclause " WITH (INDEX = $indexname)"
        }
        append fullclause ", clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_ $whereclause)"
        return $fullclause
}

proc segments::builder { {triggered_segment {}} } {

    look::preserve_user_preferences {{segments_builder QueryFieldHeight "12"} } 
	
    ncgi::setValue triggered $triggered_segment	

    # if they are picking a segment at random to edit, we must figure out if it is a triggered segment and use the correct edit page.
    if {$triggered_segment == "" && [dbinfo::is_triggered_where_clause [ncgi::value subsets_.ClauseWhere_]]} {
        lmcgi::Doc_Post "/segments/edit_triggered.tml?id=[ncgi::value id]"
    }
    if {$triggered_segment == "" && [dbinfo::is_triggered_segment [ncgi::value id]]} {
        lmcgi::Doc_Post "/segments/edit_triggered.tml?id=[ncgi::value id]"
    }
    ncgi::setValue triggered_segment $triggered_segment

    if { [lmcgi::button_pressed "show_more_text"]} {

        set QueryFieldHeight [ncgi::value QueryFieldHeight 12]
        incr QueryFieldHeight 10
        ncgi::setValue QueryFieldHeight $QueryFieldHeight

        ncgi::setValue tab_text_message.x 1
        ncgi::setValue tab_text_message.y 1

    } elseif { [lmcgi::button_pressed "show_less_text"]} {

        set QueryFieldHeight [ncgi::value QueryFieldHeight 12]
        if { $QueryFieldHeight > 12 } {
            incr QueryFieldHeight -10
            ncgi::setValue QueryFieldHeight $QueryFieldHeight
        }

        ncgi::setValue tab_text_message.x 1
        ncgi::setValue tab_text_message.y 1

    } elseif {[lmcgi::button_pressed append_and]} {
        # handle an append of 'AND'
        if {[string length [ncgi::value subsets_.ClauseWhere_]] > 0} {
            ncgi::setValue subsets_.ClauseWhere_ "[string trim [ncgi::value subsets_.ClauseWhere_]] \nAND "
        }
    
    } elseif {[lmcgi::button_pressed save] || [lmcgi::button_pressed save_test]} {
        if {[ncgi::value subsets_.ClauseFrom_] != ""} {
            misc::verify_table_list [ncgi::value subsets_.ClauseFrom_] segments "Join other tables"
        }

		if {$triggered_segment != "" && ![dbinfo::is_triggered_where_clause [ncgi::value subsets_.ClauseWhere_]]} {
			look::redirect_to_message_page "" [translation::text "There must be at least one trigger clause in a triggered segment."] "segments" 
		}


    } elseif {[lmcgi::button_pressed append_or]} {
        # handle an append of 'OR'
        if {[string length [ncgi::value subsets_.ClauseWhere_]] > 0} {
            ncgi::setValue subsets_.ClauseWhere_ "[string trim [ncgi::value subsets_.ClauseWhere_]] \nOR "
        }
    
    } elseif {[lmcgi::button_pressed append_not]} {
        # handle an append of 'NOT'
        ncgi::setValue subsets_.ClauseWhere_ "[string trim [ncgi::value subsets_.ClauseWhere_]] NOT "
    
    } elseif {[lmcgi::button_pressed append_open_paren]} {
        # handle a character append of '('
        ncgi::setValue subsets_.ClauseWhere_ "[string trim [ncgi::value subsets_.ClauseWhere_]]("
    
    } elseif {[lmcgi::button_pressed append_close_paren]} {
        # handle a character append of ')'
        
        # count the number of open parens and existing close
        # parens to disallow too many close-parens
        set open_count [regsub -all {\(} [ncgi::value subsets_.ClauseWhere_] {X} discard1]
        set close_count [regsub -all {\)} [ncgi::value subsets_.ClauseWhere_] {Y} discard2]
        if {$open_count > $close_count} {
            # if there are more opens than closes then allow the close paren
            ncgi::setValue subsets_.ClauseWhere_ "[string trim [ncgi::value subsets_.ClauseWhere_]])"
        }

    } elseif {[lmcgi::button_pressed clear_entire]} {
        # clear the entire line
        ncgi::setValue subsets_.ClauseWhere_ {}
        # tables are being joined dynamically, so should clear them too when necessary, to avoid huge inefficient queries
		ncgi::setValue subsets_.ClauseFrom_ {}

    } elseif {[lmcgi::button_pressed insert_condition]} {
        # pressed button to insert condition in query body
		if {$triggered_segment != ""} {
			lmcgi::Doc_Post "/segments/insert_conditions_triggered.tml?[lmcgi::clist_url]"
		} else {
			lmcgi::Doc_Post "/segments/insert_conditions.tml?[lmcgi::clist_url]"
		}
    
    } elseif {[lmcgi::button_pressed insert_trigger]} {
        # pressed button to insert trigger in query body
        lmcgi::Doc_Post "/segments/insert_trigger.tml?[lmcgi::clist_url]"
    
    } elseif {[lmcgi::button_pressed insert-condition-new-do]} {
		

		# create the date limitation code
		set enddatevalue [ncgi::value condition_.EndDateValue_] 
		set enddatedays [ncgi::value condition_.Days_] 
		if {$enddatevalue == "yyyy-mm-dd" || [string toupper $enddatevalue] == "NOW"} {
			set enddatevalue ""
		}
		
		# either they entered a hardcoded datetime, or we default to NOW
		if {$enddatevalue == "" || $enddatevalue == 0} {
                    set enddatecomparison "/*currentdatetime*/[dbinfo::get_systemdatetime_syntax]/*endcurrentdatetime*/"
		} else {
			if {[dbinfo::is_mssql]} {
				set enddatecomparison "CAST('$enddatevalue' AS datetime)"
			} elseif {[dbinfo::is_oracle]} {
				set enddatecomparison "TO_DATE('$enddatevalue')"
			} else {
				set enddatecomparison "( TIMESTAMP '$enddatevalue')"
			}
		}

		if {$enddatedays == 0 || $enddatedays == ""} {
			set startdatecomparison ""
		} else {
			#currently we only have days as an option, but that could change
			set timeoffsetunits "days"
			set timeoffsetvalue $enddatedays

			if {[dbinfo::is_mssql]} {
				set pastfutureoperator "-"
				if {[string compare $timeoffsetunits "hours"] == 0} {
					# the optimizer is better able to estimate rows if we do GETDATE()-X rather than using DATEADD
					set timeoffset_leftclause ""
					set timeoffset_rightclause "${pastfutureoperator}${timeoffsetvalue}/24.0"
				} elseif {[string compare $timeoffsetunits "days"] == 0} {
					# the optimizer is better able to estimate rows if we do GETDATE()-X rather than using DATEADD
					set timeoffset_leftclause ""
					set timeoffset_rightclause "${pastfutureoperator}${timeoffsetvalue}"
				} elseif {[string compare $timeoffsetunits "weeks"] == 0} {
					set timeoffset_leftclause "DATEADD( WEEK, ${pastfutureoperator}${timeoffsetvalue}, "
					set timeoffset_rightclause " )"
				} elseif {[string compare $timeoffsetunits "months"] == 0} {
					set timeoffset_leftclause "DATEADD( MONTH, ${pastfutureoperator}${timeoffsetvalue}, "
					set timeoffset_rightclause " )"
				} elseif {[string compare $timeoffsetunits "years"] == 0} {
					set timeoffset_leftclause "DATEADD( YEAR, ${pastfutureoperator}${timeoffsetvalue}, "
					set timeoffset_rightclause " )"
				}

			} elseif {[dbinfo::is_oracle]} {
				set pastfutureoperator "-"

				if {[string compare $timeoffsetunits "hours"] == 0} {
					set timeoffset_leftclause ""
					set timeoffset_rightclause " $pastfutureoperator ($timeoffsetvalue / 24)"

				} elseif {[string compare $timeoffsetunits "days"] == 0} {
					set timeoffset_leftclause ""
					set timeoffset_rightclause " $pastfutureoperator $timeoffsetvalue"

				} elseif {[string compare $timeoffsetunits "weeks"] == 0} {
					set timeoffset_leftclause ""
					set timeoffset_rightclause " $pastfutureoperator ($timeoffsetvalue * 7)"

				}

			} else {
				# assuming postgres
				set pastfutureoperator "-"
				set timeoffset_leftclause "( "
				set timeoffset_rightclause " $pastfutureoperator INTERVAL '$timeoffsetvalue $timeoffsetunits')"
			}
			set startdatecomparison "${timeoffset_leftclause}${enddatecomparison}${timeoffset_rightclause}"
		}
		
		
     	
		if { [ncgi::value current_tab] == "Text" } {
			#puts "processing for insert-condition-new-do - Text"
			set textfieldname [ncgi::value condition_.TextFieldname_]
			set textcomparator [ncgi::value condition_.TextComparator_]
			set textvalue [ncgi::value condition_.TextValue_]
			#puts "textfieldname: '$textfieldname'"
			#puts "textcomparator: '$textcomparator'"
			#puts "textvalue: '$textvalue'"

			set table_stuff [segments::get_table_stuff $textfieldname]
			set txtfieldname [lindex $table_stuff 0]
			set table_alias [lindex $table_stuff 1]
			set table_name [lindex $table_stuff 2]

			set comment ""
			if {[string compare [ncgi::value condition_.TextFieldname_] [translation::text "select a text field"]] != 0} {
				
				# retrieve the text field type, to determine what comparison operations will be allowed:

				dbinfo::get_table_info $table_name 1

				set txtfieldname_lc [string tolower $txtfieldname]


				set field_type [dbinfo::table_info $table_name $txtfieldname_lc type]
				# puts "field_type: '$field_type'"

                set match_case 0
                if { [ncgi::value condition_.MatchCase_] == "ok" } {
                    set match_case 1
                }
                #puts "match_case: $match_case"
				
		        if {[string first [ncgi::value condition_.TextComparator_] "= < <= > >= <>"] > -1} {
	    	        if {$field_type == 6} {
		                look::redirect_to_message_page "" [translation::text "That comparison operation is not allowed on this text blob field."] "segments"
		            }

                    if { $match_case == 1 } {
                        set to_append "$table_alias.$txtfieldname [ncgi::value condition_.TextComparator_][lyrsql::quote [ncgi::value condition_.TextValue_]] "
                    } else {
			            set to_append "LOWER($table_alias.$txtfieldname) [ncgi::value condition_.TextComparator_][lyrsql::quote [string tolower [ncgi::value condition_.TextValue_]]] "
                    }
		            set comment [subst [translation::text {--Text field '$textfieldname' $textcomparator '$textvalue'}]]
                    if { $match_case == 0 } {
                        append comment " (no case match)"
                    }
				} elseif {[string compare [ncgi::value condition_.TextComparator_] "contains"] == 0} {
					if {$field_type == 6 && $match_case == 0 } {
                        look::redirect_to_message_page "" [translation::text "Case matching is required on this text blob field."] "segments"
                    } else {
                        if { $match_case == 1 } {
                            set to_append "$table_alias.$txtfieldname LIKE [lyrsql::quote %[ncgi::value condition_.TextValue_]%] "
                        } else {
                            set to_append "LOWER($table_alias.$txtfieldname) LIKE [lyrsql::quote %[string tolower [ncgi::value condition_.TextValue_]]%] "
                        }
                    }
		            set comment [subst [translation::text {--Text field '$textfieldname' contains '$textvalue'}]]
                    if { $match_case == 0 } {
                        append comment " (no case match)"
                    }
				} elseif {[string compare [ncgi::value condition_.TextComparator_] "not_contains"] == 0} {
					if {$field_type == 6 && $match_case == 0 } {
                        look::redirect_to_message_page "" [translation::text "Case matching is required on this text blob field."] "segments"
                    } else {
                        if { $match_case == 1 } {
                            set to_append "( $table_alias.$txtfieldname NOT LIKE [lyrsql::quote %[ncgi::value condition_.TextValue_]%] OR $table_alias.$txtfieldname IS NULL ) "
                        } else {
                            set to_append "( LOWER($table_alias.$txtfieldname) NOT LIKE [lyrsql::quote %[string tolower [ncgi::value condition_.TextValue_]]%] OR $table_alias.$txtfieldname IS NULL ) "
                        }
                    }
					set comment [subst [translation::text {--Text field '$textfieldname' does not contain '$textvalue'}]]
                    if { $match_case == 0} {
                        append comment " (no case match)"
                    }
				} elseif {[string compare [ncgi::value condition_.TextComparator_] "beginswith"] == 0} {
					if {$field_type == 6 && $match_case == 0 } {
                        look::redirect_to_message_page "" [translation::text "Case matching is required on this text blob field."] "segments"
                    } else {
                        if { $match_case == 1 } {
                            set to_append "$table_alias.$txtfieldname LIKE [lyrsql::quote [ncgi::value condition_.TextValue_]%] "
                        } else {
                            set to_append "LOWER($table_alias.$txtfieldname) LIKE [lyrsql::quote [string tolower [ncgi::value condition_.TextValue_]]%] "
                        }
                    }
					set comment [subst [translation::text {--Text field '$textfieldname' starts with '$textvalue'}]]
                    if { $match_case == 0 } {
                        append comment " (no case match)"
                    }
				} elseif {[string compare [ncgi::value condition_.TextComparator_] "joinwith"] == 0} {

					### Lets break the textvalue (since this is a join) into alias and fieldname...
					set table_stuff [segments::get_table_stuff $textvalue]
					set j_txtfieldname [lindex $table_stuff 0]
					set j_table_alias [lindex $table_stuff 1]
                    set to_append "$table_alias.$txtfieldname = $j_table_alias.$j_txtfieldname "
					set comment [subst [translation::text {--Text field '$textfieldname' = Text field '$textvalue'}]]

				} elseif {[string compare [ncgi::value condition_.TextComparator_] "endswith"] == 0} {
					if {$field_type == 6 && $match_case == 0 } {
                        look::redirect_to_message_page "" [translation::text "Case matching is required on this text blob field."] "segments"
                    } else {
                        if { $match_case == 1 } {
                            set to_append "$table_alias.$txtfieldname LIKE [lyrsql::quote %[ncgi::value condition_.TextValue_]] "
                        } else {
                            set to_append "LOWER($table_alias.$txtfieldname) LIKE [lyrsql::quote %[string tolower [ncgi::value condition_.TextValue_]]] "
                        }
                    }
					set comment [subst [translation::text {--Text field '$textfieldname' ends with '$textvalue'}]]
                    if { $match_case == 0 } {
                        append comment " (no case match)"
                    }
				} elseif {[string compare [ncgi::value condition_.TextComparator_] "is_null"] == 0} {
					set to_append "$table_alias.$txtfieldname IS NULL "
					set comment [subst [translation::text {--Text field '$textfieldname' is null}]]
				} elseif {[string compare [ncgi::value condition_.TextComparator_] "is_not_null"] == 0} {
					set to_append "$table_alias.$txtfieldname IS NOT NULL "
					set comment [subst [translation::text {--Text field '$textfieldname' is not null}]]
				}
				#ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#ncgi::setValue subsets_.ClauseWhere_ [string trimleft "[ncgi::value subsets_.ClauseWhere_] \n$to_append"]
				ncgi::setValue subsets_.ClauseWhere_ "foo"
				
			} else {
				look::redirect_to_message_page "" [translation::text "You must select a field."] "segments" 
			}

        } elseif { [ncgi::value current_tab] == "Preferences" } {
		#
		# Adding in the preference area
		#
		set mailingclause "EXISTS"
		set pageclause "(Memberid_ in (Select memberid_ from members_)"
		set clause "(${mailingclause}${pageclause})"
		set comment [subst [translation::text {--adding in preference clause}]]
		set tableName [clock clicks -milliseconds]
		set createTableString "create table ##tmp$tableName (whereclause varchar(2000))"
		puts $createTableString
		if {[lyrsql::utility $createTableString ] == -1} {
			# now build the insert string for the stored procedure
			# parse out the values of preference list and make them comma delimited
			
			set parameter ""
			foreach item [ncgi::value subsets_.Preferences_] {
				append parameter $item,
				puts $parameter
			}
			
			if {[ncgi::value subsets_.OptStatus_] == "T"} {
				set optStatus "yes"
			} else {
				set optStatus "no"
			}
			puts $optStatus
			
			if {[ncgi::value subsets_.AnyOrAll_] == "T"} {
				set anyall "all"
			} else {
				set anyall "any"
			}
			puts $anyall
			
			# now build the stored proc execute statemnt
			set exSP "exec proc_lyris_generate_preference_clause @preference_id_list='$parameter', @opt_in_out='$optStatus', @all_or_any = '$anyall'"
			puts $exSP
			
			# and now build the insert statement
			set insertClause "insert into ##tmp$tableName (whereclause) $exSP"
			puts $insertClause
			
			set runInsert [lyrsql::utility $insertClause ]
			
			set whereClause [lyrsql::select_value "select whereclause from ##tmp$tableName"]
			puts $whereClause
			
			# and now we drop the table we created
			set dropTableString "drop table ##tmp$tableName"
		puts $dropTableString

		set drop [lyrsql::utility $dropTableString]
		
		ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \nEXISTS($whereClause)"
			
		}
	  
		
		#ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
		#ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \nEXISTS($clause)"

	} elseif { [ncgi::value current_tab] == "Numeric" } {
			#puts "processing for insert-condition-new-do - Numeric"
			set numericfieldname [ncgi::value condition_.NumericFieldname_]
			set numericcomparator [ncgi::value condition_.NumericComparator_]
			set numerictextvalue [ncgi::value condition_.NumericValue_]
			set numericvalue [lmcgi::value_int condition_.NumericValue_]
			#puts "numericfieldname: '$numericfieldname'"
			#puts "numericcomparator: '$numericcomparator'"
			#puts "numericvalue: '$numericvalue'"

			set table_stuff [segments::get_table_stuff $numericfieldname]
			set numfieldname [lindex $table_stuff 0]
			set table_alias [lindex $table_stuff 1]
			set table_name [lindex $table_stuff 2]

			if {[string compare [ncgi::value condition_.NumericFieldname_] "select a numeric field"] != 0} {
				if {[string first [ncgi::value condition_.NumericComparator_] "= < <= > >= <>"] > -1} {
					set to_append "[ncgi::value condition_.NumericComparator_][lmcgi::value_int condition_.NumericValue_] "
					set comment [subst [translation::text {--Numeric field '$numericfieldname' $numericcomparator '$numericvalue'}]]
				} elseif {[string compare [ncgi::value condition_.NumericComparator_] "joinwith"] == 0} {

					### Lets break the numericvalue (since this is a join) into alias and fieldname...
					set table_stuff [segments::get_table_stuff $numerictextvalue]
					set j_numericfieldname [lindex $table_stuff 0]
					set j_table_alias [lindex $table_stuff 1]
					set to_append " = $j_table_alias.$j_numericfieldname "
					set comment [subst [translation::text {--Numeric field '$numericfieldname' = Numeric field '$numerictextvalue'}]]

				} elseif {[string compare [ncgi::value condition_.NumericComparator_] "is_null"] == 0} {
					set to_append " IS NULL "
					set comment [subst [translation::text {--Numeric field '$numericfieldname' is null}]]
				} elseif {[string compare [ncgi::value condition_.NumericComparator_] "is_not_null"] == 0} {
					set to_append " IS NOT NULL "
					set comment [subst [translation::text {--Numeric field '$numericfieldname' is not null}]]
				}
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				ncgi::setValue subsets_.ClauseWhere_ [string trimleft "[ncgi::value subsets_.ClauseWhere_] \n$table_alias.$numfieldname $to_append"]
			} else {
				look::redirect_to_message_page "" [translation::text "You must select a field."] "segments" 
			}
			
        } elseif { [ncgi::value current_tab] == "Date" } {
			#puts "processing for insert-condition-new-do - Date"
			set datefieldname [ncgi::value condition_.DateFieldname_]
			set datecomparator [ncgi::value condition_.DateComparator_]
			set datevalue [ncgi::value condition_.DateValue_]
			set dateanniversary [ncgi::value condition_.DateAnniversary_]
			#puts "datefieldname: '$datefieldname'"
			#puts "datecomparator: '$datecomparator'"
			#puts "datevalue: '$datevalue'"


			set table_name [misc::get_table_name $datefieldname]

			if {[lindex [split $table_name] 1] ne ""} {
				set table_alias [lindex [split $table_name] 1]
			} else {
				set table_alias $table_name
			}

                        set datfieldname [lindex [split $datefieldname .] [expr [llength [split $datefieldname .]]-1]]

			if {[string compare [ncgi::value condition_.DateFieldname_] "select a date field"] != 0} {
				
				if {[string compare [ncgi::value condition_.DateAnniversary_] "exact_date_and_time"] == 0} {
					# generate SQL code for the current datetime
					if {[string toupper $datevalue] == "NOW"} {
						set datevalue "/*currentdatetime*/[dbinfo::get_systemdatetime_syntax]/*endcurrentdatetime*/"
					} else {
						set datevalue "'$datevalue'"
					}
					set comment ""
					if {[string first $datecomparator "= < <= > >= <>"] > -1} {
						set dateclause "$table_alias.$datfieldname $datecomparator $datevalue"
						set comment [subst [translation::text {--Exact Date and Time field '$datefieldname' $datecomparator $datevalue}]]

					} elseif {[string compare $datecomparator "is_null"] == 0} {
						set dateclause "$table_alias.$datfieldname  IS NULL"
						set comment [subst [translation::text {--Date field '$datefieldname' is null}]]

					} elseif {[string compare $datecomparator "is_not_null"] == 0} {
						set dateclause "$table_alias.$datfieldname  IS NOT NULL"
						set comment [subst [translation::text {--Date field '$datefieldname' is not null}]]
					}
					ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
					ncgi::setValue subsets_.ClauseWhere_ [string trimleft "[ncgi::value subsets_.ClauseWhere_] \n${dateclause}"]

				} else {
					# Anniversary of date - such as finding a person's birthday using a date-of-birth field
					set comment ""
					set formated_date $datevalue
					if {[string first $datecomparator "= < <= > >= <>"] > -1} {
						set errormessage ""
						if {[string trim [string toupper $datevalue]] == "NOW"} {
							# want to do the calculation with the system current time function:
							set systemtime "/*currentdatetime*/[dbinfo::get_systemdatetime_syntax]/*endcurrentdatetime*/"
							if {[dbinfo::is_mssql]} {
								set integerdatevalue "DATEPART( month, $systemtime ) * 100 + DATEPART( day, $systemtime )"
							} elseif {[dbinfo::is_oracle]} {
								set integerdatevalue "EXTRACT( MONTH FROM $systemtime ) * 100 + EXTRACT( DAY FROM $systemtime )"
							} else {
								set integerdatevalue "DATE_PART( 'MONTH', $systemtime ) * 100 + DATE_PART( 'DAY', $systemtime )"
							}
						} else {
							catch { 
								set formated_date [date::SQLDateTimeToDisplayJustDate $datevalue]
								set month_int [string range $formated_date 5 6]
								set day_int [string range $formated_date 8 9]
								if {[string range $month_int 0 0] == "0"} {
									set month_int [string range $month_int 1 1]
								}
								if {[string range $day_int 0 0] == "0"} {
									set day_int [string range $day_int 1 1]
								}
								set integerdatevalue [expr (int($month_int) * 100) + int($day_int)] 
								# set a null return value
								set month_int ""
							} errormessage
						}
						if {$errormessage != ""} {
							#puts "errormessage: '$errormessage'"
							set dateclause ""
							#should go to an error page?
							look::redirect_to_message_page "" [translation::text "There were problems with the date value you entered."] "utilities" $errormessage
						} else {
							#puts "integerdatevalue: '$integerdatevalue'"
							if {[dbinfo::is_mssql]} {
								set dateclause "DATEPART( month, $table_alias.$datfieldname ) * 100 + DATEPART( day, $table_alias.$datfieldname ) $datecomparator $integerdatevalue"
							} elseif {[dbinfo::is_oracle]} {
								set dateclause "EXTRACT( MONTH FROM $table_alias.$datfieldname ) * 100 + EXTRACT( DAY FROM $table_alias.$datfieldname ) $datecomparator $integerdatevalue"
							} else {
								# DEBUG - this needs to be tested.  I am not sure if it is correct.
								set dateclause "DATE_PART( 'MONTH', $table_alias.$datfieldname ) * 100 + DATE_PART( 'DAY', $table_alias.$datfieldname ) $datecomparator $integerdatevalue"
							}
							set comment [subst [translation::text {--Anniversary of Date field '$datefieldname' is $datecomparator the anniversary of '$formated_date'}]]
						}
					} elseif {[string compare $datecomparator "is_null"] == 0} {
						set dateclause "$datefieldname  IS NULL"
						set comment [subst [translation::text {--Date field '$datefieldname' is null}]]
					
					} elseif {[string compare $datecomparator "is_not_null"] == 0} {
						set dateclause "$datefieldname  IS NOT NULL"
						set comment [subst [translation::text {--Date field '$datefieldname' is not null}]]
					}
					if {$dateclause != ""} {
						ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
						ncgi::setValue subsets_.ClauseWhere_ [string trimleft "[ncgi::value subsets_.ClauseWhere_] \n${dateclause}"]
					}
				}
			} else {
				look::redirect_to_message_page "" [translation::text "You must select a field."] "segments" 
			}
		
		} elseif { [ncgi::value current_tab] == "Action" } {
			#puts "processing for insert-condition-new-do - Action"
			set action [ncgi::value condition_.Action_]
			set actionmailing [ncgi::value condition_.ActionMailing_]
            # ctindexname tells us which index we want to hint for this query.  by default we don't hint at all (let DB decide).
            set ctindexname ""

            if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] != 0} {
                # we use the IX_clicktracking_DupChk index which starts with MailingID and includes many other useful fields
                set ctindexname "IX_clicktracking_DupChk"
            }

			#puts "action: '$action'"
			#puts "actionmailing: '$actionmailing'"
			
            # eventually we need to add some kind of index(es) on TimeClicked_ and hint for it if we are using that column and not MailingID
			set datecomparisonclause ""
			if {$enddatevalue != "" && $enddatevalue != 0} {
				set datecomparisonclause " AND clicktracking_.TimeClicked_ <= ${enddatecomparison}"
			}
			if {$startdatecomparison != ""} {
				append datecomparisonclause " AND clicktracking_.TimeClicked_ > ${startdatecomparison}"
			}
            if {$datecomparisonclause != "" && $ctindexname == ""} {
                set ctindexname "IX_clicktracking_TimeClicked"
            }

	# code below was used in htdocs/reports/mailings/view_opens.tml for the "create new segment" button 
	# changes to this code should be moved back there as necessary
	
			if {[string compare [ncgi::value condition_.Action_] "opened"] == 0} {	
				#set clause "(clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] and clicktracking_.UrlID_ IS NULL and clicktracking_.StreamWebPageName_ IS NULL)"
				# NOTE - we are using any means necessary to determine if a person opened the mailing, not just an open-detect event
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					# this is a simple meaningless line to indicate that there is at least one record for this member in clicktracking_
					set clause " AND (clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
				} else {
					set clause " AND (clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NULL) AND clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_]"
				}
				set fullclause "("
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				set comment [subst [translation::text {--Action: opened mailing '$actionmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n${fullclause}"
			
			} elseif {[string compare [ncgi::value condition_.Action_] "did_not_open"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					# this is a simple meaningless line to indicate that there is at least one record for this member in clicktracking_
					set clause " AND (clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
                    set receive_message_clause ""
				} else {
					set clause " AND (clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NULL) AND (clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_])"
                    set receive_message_clause "AND lyrCompletedRecips.MailingID=[lmcgi::value_int condition_.ActionMailing_]"
				}
				set open_clause "(NOT "
                append open_clause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"

                set receive_clause "(EXISTS (SELECT NULL FROM lyrCompletedRecips WHERE lyrCompletedRecips.MemberID=members_.MemberID_ and ([sqlutil::status_sql CompletionStatusID {success}]) $receive_message_clause))"

				set comment [subst [translation::text {--Action: did not open mailing '$actionmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n--$comment"
				#segments::appendtable "clicktracking_"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n(${open_clause} AND ${receive_clause})"
			
			} elseif {[string compare [ncgi::value condition_.Action_] "clicked_on_any_url_in"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause " AND (clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
				} else {
					set clause " AND (clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
				}
                set ctindexname "IX_clicktracking_DupChk"
				set fullclause "("
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				set comment [subst [translation::text {--Action: clicked on any url in mailing '$actionmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n${fullclause}"
			
			} elseif {[string compare [ncgi::value condition_.Action_] "did_not_click_on_any_url_in"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause " AND (clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
				} else {
					set clause " AND (clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
				}
                set ctindexname "IX_clicktracking_DupChk"
				set fullclause "(NOT "
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				set comment [subst [translation::text {--Action: did not click on any url in mailing '$actionmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n${fullclause}"
			
			} elseif {[string compare [ncgi::value condition_.Action_] "visited_from"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause " AND (clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL)"
				} else {
					set clause " AND (clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL)"
				}
				set fullclause "("
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				set comment [subst [translation::text {--Action: visited from mailing '$actionmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n${fullclause}"
			
			} elseif {[string compare [ncgi::value condition_.Action_] "did_not_visit_from"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause " AND (clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL)"
				} else {
					set clause " AND (clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL)"
				}
				set comment [subst [translation::text {--Action: did not visit from mailing '$actionmailing'}]]
				set fullclause "(NOT "
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n${fullclause}"
			
			} elseif {[string compare [ncgi::value condition_.Action_] "purchased_from"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause "(clickstreamdata_.Quantity_ > 0)"
				} else {
					set clause "(clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clickstreamdata_.Quantity_ > 0)"
				}
				set fullclause "("
                append fullclause [segments::clickstreamdata_exists "$clause $datecomparisonclause" $ctindexname] ")"
				set comment [subst [translation::text {--Action: purchased from mailing '$actionmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				#segments::appendtable "clickstreamdata_"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n${fullclause}"
			
			} elseif {[string compare [ncgi::value condition_.Action_] "did_not_purchase_from"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause "(clickstreamdata_.Quantity_ > 0)"
				} else {
					set clause "(clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clickstreamdata_.Quantity_ > 0)"
				}
				set fullclause "(NOT "
                append fullclause [segments::clickstreamdata_exists "$clause $datecomparisonclause" $ctindexname] ")"
				set comment [subst [translation::text {--Action: did not purchase from mailing '$actionmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				#segments::appendtable "clickstreamdata_"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n${fullclause}"
			}

        } elseif { [ncgi::value current_tab] == "Clickthrough" } {

	# code below was used in htdocs/reports/mailings/view_clickthroughs.tml for the "create new segment" button 
	# changes to this code should be moved back there as necessary
	
			#puts "processing for insert-condition-new-do - Clickthrough"
			set clickthrough [ncgi::value condition_.ClickthroughAction_]
			set clickthroughurl [ncgi::value condition_.ClickthroughUrl_]
			set clickthroughmailing [ncgi::value condition_.ClickthroughMailing_]
			#puts "clickthrough: '$clickthrough'"
			#puts "clickthroughurl: '$clickthroughurl'"
			#puts "clickthroughmailing: '$clickthroughmailing'"

            # ctindexname tells us which index we want to hint for this query.  by default we don't hint at all (let DB decide).
            set ctindexname ""
            if {[string compare [ncgi::value condition_.ClickthroughMailing_] "any_mailing"] != 0} {
                # we use the IX_clicktracking_DupChk index which starts with MailingID and includes many other useful fields
                set ctindexname "IX_clicktracking_DupChk"
            }

            # eventually we need to add some kind of index(es) on TimeClicked_ and hint for it if we are using that column and not MailingID
			set datecomparisonclause ""
			if {$enddatevalue != "" && $enddatevalue != 0} {
				set datecomparisonclause " AND clicktracking_.TimeClicked_ <= ${enddatecomparison}"
			}
			if {$startdatecomparison != ""} {
				append datecomparisonclause " AND clicktracking_.TimeClicked_ > ${startdatecomparison}"
			}
            if {$datecomparisonclause != "" && $ctindexname == ""} {
                set ctindexname "IX_clicktracking_TimeClicked"
            }

			if {[string compare [ncgi::value condition_.ClickthroughAction_] "clicked_on"] == 0} {	
				if {[string compare [ncgi::value condition_.ClickthroughMailing_] "any_mailing"] == 0} {
					set mailingclause ""
				} else {
					set mailingclause "clicktracking_.MessageID_=[lmcgi::value_int condition_.ClickthroughMailing_] AND "
				}
				if {[string compare [ncgi::value condition_.ClickthroughUrl_] "any_url"] == 0} {
					set urlclause "clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL"
				} else {
					set urlclause "clicktracking_.UrlID_=[lmcgi::value_int condition_.ClickthroughUrl_] AND clicktracking_.StreamWebPageName_ IS NULL"
				}
				set clause " AND (${mailingclause}${urlclause})"
				set comment [subst [translation::text {--Clickthrough: clicked on url '$clickthroughurl' in mailing '$clickthroughmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
		   		#segments::appendtable "clicktracking_"

				set fullclause "("
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$fullclause"

			} elseif {[string compare [ncgi::value condition_.ClickthroughAction_] "did_not_click_on"] == 0} {
				# SUBQUERY REQUIRED			
				if {[string compare [ncgi::value condition_.ClickthroughMailing_] "any_mailing"] == 0} {
					set mailingclause ""
				} else {
					set mailingclause "clicktracking_.MessageID_=[lmcgi::value_int condition_.ClickthroughMailing_] AND "
				}
				if {[string compare [ncgi::value condition_.ClickthroughUrl_] "any_url"] == 0} {
					set urlclause "clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL"
				} else {
					set urlclause "clicktracking_.UrlID_=[lmcgi::value_int condition_.ClickthroughUrl_] AND clicktracking_.StreamWebPageName_ IS NULL"
				}
				set clause " AND (${mailingclause}${urlclause})"
				set comment [subst [translation::text {--Clickthrough: did not click on url '$clickthroughurl' in mailing '$clickthroughmailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
		   		#segments::appendtable "clicktracking_"
				set fullclause "(NOT "
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$fullclause"
			}

        } elseif { [ncgi::value current_tab] == "Clickstream" } {

	# code below was used in htdocs/reports/mailings/view_clickstreams.tml for the "create new segment" button 
	# changes to this code should be moved back there as necessary
	
			#puts "processing for insert-condition-new-do - Clickstream"
			set clickstream [ncgi::value condition_.ClickstreamAction_]
			set clickstreampage [ncgi::value condition_.ClickstreamPage_]
			set clickstreammailing [ncgi::value condition_.ClickstreamMailing_]
			#puts "clickstream: '$clickstream'"
			#puts "clickstreampage: '$clickstreampage'"
			#puts "clickstreammailing: '$clickstreammailing'"

            # ctindexname tells us which index we want to hint for this query.  by default we don't hint at all (let DB decide).
            set ctindexname ""
            if {[string compare [ncgi::value condition_.ClickstreamMailing_] "any_mailing"] != 0} {
                # we use the IX_clicktracking_DupChk index which starts with MailingID and includes many other useful fields
                set ctindexname "IX_clicktracking_DupChk"
            }
            
			set datecomparisonclause ""
			if {$enddatevalue != "" && $enddatevalue != 0} {
				set datecomparisonclause " AND clicktracking_.TimeClicked_ <= ${enddatecomparison}"
			}
			if {$startdatecomparison != ""} {
				append datecomparisonclause " AND clicktracking_.TimeClicked_ > ${startdatecomparison}"
			}
            if {$datecomparisonclause != "" && $ctindexname == ""} {
                set ctindexname "IX_clicktracking_TimeClicked"
            }
			
			if {[string compare [ncgi::value condition_.ClickstreamAction_] "viewed"] == 0} {	
				if {[string compare [ncgi::value condition_.ClickstreamMailing_] "any_mailing"] == 0} {
					set mailingclause ""
				} else {
					set mailingclause "clicktracking_.MessageID_=[lmcgi::value_int condition_.ClickstreamMailing_] AND "
				}
				if {[string compare [ncgi::value condition_.ClickstreamPage_] "any_page"] == 0} {
					set pageclause "clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL"
				} else {
					set pageclause "clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_='[ncgi::value condition_.ClickstreamPage_]'"
				}
				set clause " AND (${mailingclause}${pageclause})"
				set comment [subst [translation::text {--Clickstream: clicked on page '$clickstreampage' in mailing '$clickstreammailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				set fullclause "("
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$fullclause"
			} elseif {[string compare [ncgi::value condition_.ClickstreamAction_] "did_not_view"] == 0} {
				# SUBQUERY REQUIRED			
				if {[string compare [ncgi::value condition_.ClickstreamMailing_] "any_mailing"] == 0} {
					set mailingclause ""
				} else {
					set mailingclause "clicktracking_.MessageID_=[lmcgi::value_int condition_.ClickstreamMailing_] AND "
				}
				if {[string compare [ncgi::value condition_.ClickstreamPage_] "any_page"] == 0} {
					set pageclause "clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL"
				} else {
					set pageclause "clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_='[ncgi::value condition_.ClickstreamPage_]'"
				}
				set clause " AND (${mailingclause}${pageclause})"
				set comment [subst [translation::text {--Clickstream: did not click on page '$clickstreampage' in mailing '$clickstreammailing'}]]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				#segments::appendtable "clicktracking_"
				set fullclause "(NOT "
                append fullclause [sqlutil::clicktracking_exists "$clause $datecomparisonclause" $ctindexname] ")"
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$fullclause"
			}

        } elseif { [ncgi::value current_tab] == "Purchase" } {
			#puts "processing for insert-condition-new-do - Purchase"
			set PurchaseAmountComparator [ncgi::value condition_.PurchaseAmountComparator_]
			set PurchaseAmount [ncgi::value condition_.PurchaseAmount_]
			#set PurchaseAggregation [ncgi::value condition_.PurchaseAggregation_]
			set PurchaseDays [ncgi::value condition_.PurchaseDays_]
			set PurchaseType [ncgi::value condition_.PurchaseType_]
                        set PurchaseSkuList [ncgi::valueList condition_.PurchaseSKU_]
			set PurchasePage [ncgi::value condition_.PurchasePage_]
			set PurchaseMailing [ncgi::value condition_.PurchaseMailing_]
			#puts "PurchaseAmountComparator: '$PurchaseAmountComparator'"
			#puts "PurchaseAmount: '$PurchaseAmount'"
			#puts "PurchaseAggregation: '$PurchaseAggregation'"
			#puts "PurchaseDays: '$PurchaseDays'"
			#puts "PurchaseType: '$PurchaseType'"
			#puts "PurchaseSkuList: '$PurchaseSkuList'"
			#puts "PurchasePage: '$PurchasePage'"
			#puts "PurchaseMailing: '$PurchaseMailing'"

            # ctindexname tells us which index we want to hint for this query.  by default we don't hint at all (let DB decide).
            set ctindexname ""
            if {[string compare [ncgi::value condition_.PurchaseMailing_] "any_mailing"] != 0} {
                # we use the IX_clicktracking_DupChk index which starts with MailingID and includes many other useful fields
                set ctindexname "IX_clicktracking_DupChk"
            }
			
			set datecomparisonclause ""
			if {$enddatevalue != "" && $enddatevalue != 0} {
				set datecomparisonclause " AND clicktracking_.TimeClicked_ <= ${enddatecomparison}"
			}
			if {$startdatecomparison != ""} {
				append datecomparisonclause " AND clicktracking_.TimeClicked_ > ${startdatecomparison}"
			}
            if {$datecomparisonclause != "" && $ctindexname == ""} {
                set ctindexname "IX_clicktracking_TimeClicked"
            }

			# Sections to handle:
			# 1) amount comparison - aggregation 
			# Price or Quantity:
			if {[string compare [ncgi::value condition_.PurchaseType_] "p"] == 0} {
				set amounttypefield "clickstreamdata_.Quantity_*clickstreamdata_.UnitPrice_"
				set amounttypecomment [translation::text "(by price)"]
			} else {
				set amounttypefield "clickstreamdata_.Quantity_"
				set amounttypecomment [translation::text "(by quantity)"]
			}

			# 3) page criteria
			if {[string compare [ncgi::value condition_.PurchasePage_] "any_page"] == 0} {
				set pageclause ""
			} else {
				set pageclause " AND clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_=[lyrsql::quote [ncgi::value condition_.PurchasePage_]]"
			}
			# 4) specific mailing
			if {[string compare [ncgi::value condition_.PurchaseMailing_] "any_mailing"] == 0} {
				set mailingclause ""
			} else {
				set mailingclause " AND clicktracking_.MessageID_=[lmcgi::value_int condition_.PurchaseMailing_] "
			}
			# 6) product/SKU
			if {[llength $PurchaseSkuList] == 0 || ([llength $PurchaseSkuList] == 1 && [string length [string trim [lindex $PurchaseSkuList 0]]] == 0) } {
				set productclause ""
				set productnamecomment ""
			} else {
                if { [llength $PurchaseSkuList] == 1 } {
                    set PurchaseSku [lindex $PurchaseSkuList 0]
                    set productclause " AND clickstreamdata_.ProductSku_=[lyrsql::quote $PurchaseSku]"
                    set productnamecomment [subst [translation::text { of product [lyrsql::quote $PurchaseSku]} ]]
                } else {
                    set PurchaseSkuListQuoted {}
                    foreach PurchaseSku $PurchaseSkuList {
                        lappend PurchaseSkuListQuoted [lyrsql::quote $PurchaseSku]
                    }
                    set ProductSkuCommaList [join $PurchaseSkuListQuoted {, }]
                    set productclause " AND clickstreamdata_.ProductSku_ in ( $ProductSkuCommaList )"
                    set productnamecomment [subst [translation::text { of products $ProductSkuCommaList } ]]
                }
			}
			
            set whereclause " AND clickstreamdata_.Quantity_ > 0 "
            set clause [segments::clickstreamdata_amountcompare "SUM($amounttypefield)" $whereclause$datecomparisonclause$mailingclause$productclause$pageclause $PurchaseAmount $PurchaseAmountComparator $ctindexname]
			
			if {[lmcgi::value_int condition_.PurchaseDays_] == 0} {
				set dayscomment ""
			} else {
				set dayscomment [subst [translation::text { in the last $PurchaseDays days}]]
			}
			set comment [subst [translation::text {--Purchase: purchased $PurchaseAmountComparator$PurchaseAmount $amounttypecomment$productnamecomment on page '$PurchasePage' from mailing '$PurchaseMailing'$dayscomment}]]
			ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
			#segments::appendtable "clicktracking_"
			#segments::appendtable "clickstreamdata_"
			ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n($clause)"
			
			
        } elseif { [ncgi::value current_tab] == "Interest" } {
			#puts "processing for insert-condition-new-do - Interest"
			set InterestAmountComparator [ncgi::value condition_.InterestAmountComparator_]
			set InterestAmount [ncgi::value condition_.InterestAmount_]
			set InterestType [ncgi::value condition_.InterestType_]
			set InterestDays [ncgi::value condition_.InterestDays_]
			set InterestPage [ncgi::value condition_.InterestPage_]
			set InterestMailing [ncgi::value condition_.InterestMailing_]
			#puts "InterestAmountComparator: '$InterestAmountComparator'"
			#puts "InterestAmount: '$InterestAmount'"
			#puts "InterestDays: '$InterestDays'"
			#puts "InterestType: '$InterestType'"
			#puts "InterestPage: '$InterestPage'"
			#puts "InterestMailing: '$InterestMailing'"
			
            # ctindexname tells us which index we want to hint for this query.  by default we don't hint at all (let DB decide).
            set ctindexname ""
            if {[string compare [ncgi::value condition_.InterestMailing_] "any_mailing"] != 0} {
                # we use the IX_clicktracking_DupChk index which starts with MailingID and includes many other useful fields
                set ctindexname "IX_clicktracking_DupChk"
            }
			
			set datecomparisonclause ""
			if {$enddatevalue != "" && $enddatevalue != 0} {
				set datecomparisonclause " AND clicktracking_.TimeClicked_ <= ${enddatecomparison}"
			}
			if {$startdatecomparison != ""} {
				append datecomparisonclause " AND clicktracking_.TimeClicked_ > ${startdatecomparison}"
			}
            if {$datecomparisonclause != "" && $ctindexname == ""} {
                set ctindexname "IX_clicktracking_TimeClicked"
            }
			
			# Sections to handle:
			# 1) amount comparison - aggregation (can this be done? NEEDS SUBQUERY)
			if {[ncgi::value condition_.InterestType_] == "p"} {
				# Interest Points: sum interest points with a subquery
				set interestcriteria "SUM(clickstreamdata_.Points_)"
			} elseif {[ncgi::value condition_.InterestType_] == "s"} {
				# Interest Stage: find highest stage
				set interestcriteria "MAX(clickstreamdata_.Stage_)"
			} else {
				# Interest Events: count all events 
				set interestcriteria "COUNT(*)"
			}
			set amountcomparison "SELECT ${interestcriteria} FROM clicktracking_, clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_"
			# 3) page criteria
			if {[string compare [ncgi::value condition_.InterestPage_] "any_page"] == 0} {
				set pageclause ""
			} else {
				set pageclause " AND clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_=[lyrsql::quote [ncgi::value condition_.InterestPage_]]"
			}
			# 4) specific mailing
			if {[string compare [ncgi::value condition_.InterestMailing_] "any_mailing"] == 0} {
				set mailingclause ""
			} else {
				set mailingclause " AND clicktracking_.MessageID_=[lmcgi::value_int condition_.InterestMailing_] "
			}

            set clause [segments::clickstreamdata_amountcompare $interestcriteria $datecomparisonclause$mailingclause$pageclause $InterestAmount $InterestAmountComparator $ctindexname]

			if {[lmcgi::value_int condition_.InterestDays_] == 0} {
				set dayscomment ""
			} else {
				set dayscomment [subst [translation::text { in the last $InterestDays days}]]
			}
			if {[ncgi::value condition_.InterestType_] == "p"} {
				set typecomment [translation::text "Interest Points" ]
			} elseif {[ncgi::value condition_.InterestType_] == "e"} {
				set typecomment [translation::text "Interest Events" ]
			} else {
				set typecomment [translation::text "Interest Stage" ]
			}
			set comment [subst [translation::text {--Interest: reached ${InterestAmountComparator}${InterestAmount} $typecomment on page '[ncgi::value condition_.InterestPage_]' from mailing '[ncgi::value condition_.InterestMailing_]'$dayscomment}]]
			ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
			ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n($clause)"

        } elseif { [ncgi::value current_tab] == "Survey" } {

			set comment ""
			set clause ""

			#puts "---------------------------------------------------------------"
			#puts "generating survey SQL"
			#puts "---------------------------------------------------------------"

			# Form dropdown fields:
			#puts "SurveyRespondAction: '[ncgi::value condition_.SurveyRespondAction]'"
			#puts "SurveyWebForm: '[ncgi::value condition_.SurveyWebForm]'"
			#puts "SurveyQuestionAction: '[ncgi::value condition_.SurveyQuestionAction]'"
			#puts "SurveyQuestion: '[ncgi::value condition_.SurveyQuestion]'"
			#puts "SurveyAnswerAction: '[ncgi::value condition_.SurveyAnswerAction]'"
			#puts "SurveyAnswer: '[ncgi::value condition_.SurveyAnswer]'"
			#puts "Multiple: '[ncgi::value condition_.Multiple]'"
			
			set SurveyRespondAction [ncgi::value condition_.SurveyRespondAction]
			set SurveyWebForm [ncgi::value condition_.SurveyWebForm]
			set SurveyQuestionAction [ncgi::value condition_.SurveyQuestionAction]
			set SurveyQuestion [ncgi::value condition_.SurveyQuestion]
			set SurveyAnswerAction [ncgi::value condition_.SurveyAnswerAction]
			set SurveyAnswer [ncgi::value condition_.SurveyAnswer]
			set Multiple [ncgi::value condition_.Multiple]
			set SurveyTextComparator [ncgi::value condition_.SurveyTextComparator]
			set SurveyTextValue [ncgi::value condition_.SurveyTextValue]

			# 1) responded/not_responded to any survey 
			if {$SurveyWebForm == "any_survey"} {
				if {$SurveyRespondAction == "responded_to"} {
					if {$Multiple == "n"} {
						set comment [subst [translation::text {-- Survey: responded to any survey}]]
						set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID)"
					} elseif {$Multiple == "q"} {
						if {[ncgi::value condition_.SurveyQuestionsAnsweredValue_] != [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_]} {
							look::redirect_to_message_page "" [translation::text "You must enter an integer value for the 'This many questions' field"] "segments" 
						}
						set comment [subst [translation::text {-- Survey: responded to any survey with [ncgi::value condition_.SurveyQuestionsAnsweredComparator_] [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_] questions answered}]]
						set clause "EXISTS ( SELECT * FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND ( (SELECT COUNT(*) FROM lyrSurveyResponseAnswers ra WHERE r.ResponseID = ra.ResponseID) [ncgi::value condition_.SurveyQuestionsAnsweredComparator_] [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_] ) )"
					}
				} elseif {$SurveyRespondAction == "did_not_respond_to"} {
					set comment [subst [translation::text {-- Survey: did not respond to any survey}]]
					set clause "NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID)"
				}
			} else {

				# 2) responded/not responded to a specific survey:
				if {$Multiple == "n"} {
					# 2a) with no extra filtering
					if {$SurveyRespondAction == "responded_to"} {
						set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]'}]]
						set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
					} elseif {$SurveyRespondAction == "did_not_respond_to"} {
						set comment [subst [translation::text {-- Survey: did not respond to survey '[segments::survey_form_name $SurveyWebForm]'}]]
						set clause "NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
					}
				} elseif {$Multiple == "q"} {
					# 2b) with number of questions answered filtering
					if {[ncgi::value condition_.SurveyQuestionsAnsweredValue_] != [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_]} {
						look::redirect_to_message_page "" [translation::text "You must enter an integer value for the 'This many questions' field"] "segments" 
					}
					set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' with [ncgi::value condition_.SurveyQuestionsAnsweredComparator_] [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_] questions answered}]]
					set clause "EXISTS ( SELECT * FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm] AND ( (SELECT COUNT(*) FROM lyrSurveyResponseAnswers ra WHERE r.ResponseID = ra.ResponseID) [ncgi::value condition_.SurveyQuestionsAnsweredComparator_] [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_] ) )"
				
				} elseif {$Multiple == "p"} {
					# 2c) with filtering on specific question
					if {$SurveyQuestionAction == "did_not_answer"} {
						#   i) did not answer a question 
						if {$SurveyQuestion == "choose_a_question"} {
							look::redirect_to_message_page "" [translation::text "You must choose a question"] "segments" 
						} else {
							set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and did not answer question '[segments::survey_question_name $SurveyQuestion]'}]]
							set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
							append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm] AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
						}
					} else {
						if {$SurveyQuestion == "choose_a_question"} {
							look::redirect_to_message_page "" [translation::text "You must choose a question"] "segments" 
						} else {
							if {$SurveyAnswer == "any_answer"} {
								if {$SurveyAnswerAction == "selected"} {
									#   ii) answered a question, with any answer selected 
									set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and selected any answer to question '[segments::survey_question_name $SurveyQuestion]'}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
								} else {
									#   ii) answered a question, with any answer not selected (what will this mean?)  (error page?)
									set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and did not select any answer to question '[segments::survey_question_name $SurveyQuestion]'}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
									append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
								}
							} elseif {$SurveyAnswer == "any_multiple_choice"} {
								if {$SurveyAnswerAction == "selected"} {
									#   iii) answered a question, with any multiple-choice answer selected 
									set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and selected any multiple-choice answer to question '[segments::survey_question_name $SurveyQuestion]'}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.AnswerID IS NOT NULL AND ra.FreeFormAnswer IS NULL)"
								} else {
									#   iii) answered a question, with any multiple-choice answer not selected 
									set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and answered question '[segments::survey_question_name $SurveyQuestion]' but did not select any multiple-choice answer}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
									append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.AnswerID IS NOT NULL AND ra.FreeFormAnswer IS NULL)"
								}
							
							} elseif {$SurveyAnswer == "freeform"} {
								if {$SurveyAnswerAction == "selected"} {
									#   iv) answered a question, with a free-form text answer selected 
									if {$SurveyTextComparator == "is_not_null"} {
										set textcomment ""
										set textclause ""
									} elseif {$SurveyTextComparator == "contains"} {
										set textcomment [subst [translation::text { which contains '$SurveyTextValue'}]]
										set textclause " AND ra.FreeFormAnswer LIKE [lyrsql::quote %[ncgi::value condition_.SurveyTextValue]%] "
									} elseif {$SurveyTextComparator == "not_contains"} {
										set textcomment [subst [translation::text { which does not contain '$SurveyTextValue'}]]
										set textclause " AND ra.FreeFormAnswer NOT LIKE [lyrsql::quote %[ncgi::value condition_.SurveyTextValue]%] "
									} elseif {$SurveyTextComparator == "endswith"} {
										set textcomment [subst [translation::text { which ends with '$SurveyTextValue'}]]
										set textclause " AND ra.FreeFormAnswer LIKE [lyrsql::quote %[ncgi::value condition_.SurveyTextValue]] "
									} elseif {$SurveyTextComparator == "beginswith"} {
										set textcomment [subst [translation::text { which begins with '$SurveyTextValue'}]]
										set textclause " AND ra.FreeFormAnswer LIKE [lyrsql::quote [ncgi::value condition_.SurveyTextValue]%] "
									}
									set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and entered a free-form text answer to question '[segments::survey_question_name $SurveyQuestion]'}]]
									append comment $textcomment
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.FreeFormAnswer IS NOT NULL $textclause)"
								
								} else {
									#   iv) answered a question, with a free-form text answer not selected 
									set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and answered question '[segments::survey_question_name $SurveyQuestion]' but did not enter a free-form text answer}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
									append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.FreeFormAnswer IS NOT NULL)"
								}
							} else {
								if {$SurveyAnswerAction == "selected"} {
									# Answered a particular multiple-choice answer to a particular question   
									set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and selected the answer '[segments::survey_answer_name $SurveyAnswer]' to the question '[segments::survey_question_name $SurveyQuestion]'}]]
									append clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.AnswerID = [lmcgi::value_int condition_.SurveyAnswer])"
								} else {
									# Did not answered a particular multiple-choice answer to a particular question   
									set comment [subst [translation::text {-- Survey: responded to survey '[segments::survey_form_name $SurveyWebForm]' and did not select the answer '[segments::survey_answer_name $SurveyAnswer]' to the question '[segments::survey_question_name $SurveyQuestion]'}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
									append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.AnswerID = [lmcgi::value_int condition_.SurveyAnswer])"
								}

							}
						}
					}
				}
			}

			ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
			ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n($clause)"
        }

    } elseif {[lmcgi::button_pressed insert-trigger-new-do] && [security::triggered_mailings_allowed]} {
		# Processing for inserting a trigger into the query 
		
		# initialize
		set timeoffsetvalue 0
		set timeoffsetunits ""
		set timeoffsetpastfuture ""
		set dateanniversary ""
		set triggerdateclause ""
		set timeoffset_leftclause ""
		set timeoffset_rightclause ""
		set comment ""
		
		# STEP 1) 
		# Determine the clause that returns the appropriate datetime field
		
		if { [ncgi::value current_tab] == "Date" } {
			# simple date field from the members_ table
			#puts "processing for insert-trigger-new-do - Date"
			set dateanniversary [ncgi::value condition_.DateAnniversary_]
			set DateFieldname [ncgi::value condition_.DateFieldname_]
			set timeoffsetvalue [ncgi::value condition_.DateTimeFromEventValue_]
			set timeoffsetunits [ncgi::value condition_.DateTimeFromEventUnits_]
			set timeoffsetpastfuture [ncgi::value condition_.DateTimeFromEventPastFuture_]
			#puts "dateanniversary: '$dateanniversary'"
			#puts "DateFieldname: '$DateFieldname'"
			#puts "timeoffsetvalue: '$timeoffsetvalue'"
			#puts "timeoffsetunits: '$timeoffsetunits'"
			#puts "timeoffsetpastfuture: '$timeoffsetpastfuture'"
			if {[string compare [ncgi::value condition_.DateFieldname_] "select a date field"] != 0} {
				if {[string compare $dateanniversary "exact_date_and_time"] == 0} {
					set triggerdateclause "$DateFieldname"
					set comment [subst [translation::text {--Date Trigger on the field '$DateFieldname'}]]
				} elseif {[string compare $dateanniversary "anniversary"] == 0} {
					set triggerdateclause "$DateFieldname"
					set comment [subst [translation::text {--Date Trigger on the field '$DateFieldname'}]]
				}
			} else {
				look::redirect_to_message_page "" [translation::text "You must select a field."] "segments" 
			}

		} elseif { [ncgi::value current_tab] == "Action" } {
			
			#puts "processing for insert-trigger-new-do - Action"
			
			set action [ncgi::value condition_.Action_]
			set actionmailing [ncgi::value condition_.ActionMailing_]
			#puts "action: '$action'"
			#puts "actionmailing: '$actionmailing'"
			set timeoffsetvalue [ncgi::value condition_.ActionTimeFromEventValue_]
			set timeoffsetunits [ncgi::value condition_.ActionTimeFromEventUnits_]
			set timeoffsetpastfuture [ncgi::value condition_.ActionTimeFromEventPastFuture_]
			set ActionAggregationType [ncgi::value condition_.ActionAggregationType_]
			#puts "timeoffsetvalue: '$timeoffsetvalue'"
			#puts "timeoffsetunits: '$timeoffsetunits'"
			#puts "timeoffsetpastfuture: '$timeoffsetpastfuture'"
			#puts "ActionAggregationType: '$ActionAggregationType'"

			if {[string compare [ncgi::value condition_.Action_] "opened"] == 0} {	
				#set clause "(clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] and clicktracking_.UrlID_ IS NULL and clicktracking_.StreamWebPageName_ IS NULL)"
				# NOTE - we are using any means necessary to determine if a person opened the mailing, not just an open-detect event
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					# this is a simple meaningless line to indicate that there is at least one record for this member in clicktracking_
					set clause "(clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
				} else {
					set clause "(clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NULL AND clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_])"
				}
				set comment [subst [translation::text {--Action Trigger: opened mailing '$actionmailing'}]]
				set triggerdateclause "EXISTS (SELECT clicktracking_.TimeClicked_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause %%timeclickedclause%%)"
				if {$ActionAggregationType == "f"} {
					append triggerdateclause " AND NOT EXISTS (SELECT clicktracking_.TimeClicked_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause AND %%timeclicked_lasttime_clause%%)"
					append comment " for the first time"
				} 

			} elseif {[string compare [ncgi::value condition_.Action_] "clicked_on_any_url_in"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause "(clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
				} else {
					set clause "(clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL)"
				}
				set comment [subst [translation::text {--Action Trigger: clicked on any url in mailing '$actionmailing'}]]
				set triggerdateclause "EXISTS (SELECT clicktracking_.TimeClicked_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause %%timeclickedclause%%)"
				#puts "triggerdateclause: '$triggerdateclause'"
				if {$ActionAggregationType == "f"} {
				  append triggerdateclause " AND NOT EXISTS (SELECT clicktracking_.TimeClicked_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause AND %%timeclicked_lasttime_clause%%)"
				  append comment " for the first time"
				}

			} elseif {[string compare [ncgi::value condition_.Action_] "visited_any_page"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause "(clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL)"
				} else {
					set clause "(clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL)"
				}
				set comment [subst [translation::text {--Action Trigger: visited from mailing '$actionmailing'}]]
				set triggerdateclause "EXISTS (SELECT clicktracking_.TimeClicked_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause %%timeclickedclause%%)"
				if {$ActionAggregationType == "f"} {
				   append triggerdateclause " AND NOT EXISTS (SELECT clicktracking_.TimeClicked_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause AND %%timeclicked_lasttime_clause%%)"
				   append comment " for the first time"
				}

			} elseif {[string compare [ncgi::value condition_.Action_] "purchased_after"] == 0} {
				if {[string compare [ncgi::value condition_.ActionMailing_] "any_mailing"] == 0} {
					set clause "(clickstreamdata_.Quantity_ > 0)"
				} else {
					set clause "(clicktracking_.MessageID_=[lmcgi::value_int condition_.ActionMailing_] AND clickstreamdata_.Quantity_ > 0)"
				}
				set comment [subst [translation::text {--Action Trigger: purchased from mailing '$actionmailing'}]]
				set triggerdateclause "EXISTS (SELECT clicktracking_.MemberID_ FROM clicktracking_, clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_ AND $clause %%timeclickedclause%%)"
				if {$ActionAggregationType == "f"} {
					append triggerdateclause " AND NOT EXISTS (SELECT clicktracking_.MemberID_ FROM clicktracking_, clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_ AND $clause AND %%timeclicked_lasttime_clause%%)"
					append comment " for the first time"
				}
			}
			set triggerdateclause ($triggerdateclause)

        } elseif { [ncgi::value current_tab] == "Clickthrough" } {
			#puts "processing for insert-trigger-new-do - Clickthrough"
			set clickthrough [ncgi::value condition_.ClickthroughAction_]
			set clickthroughurl [ncgi::value condition_.ClickthroughUrl_]
			set clickthroughmailing [ncgi::value condition_.ClickthroughMailing_]
			#puts "clickthrough: '$clickthrough'"
			#puts "clickthroughurl: '$clickthroughurl'"
			#puts "clickthroughmailing: '$clickthroughmailing'"
			set timeoffsetvalue [ncgi::value condition_.ClickthroughTimeFromEventValue_]
			set timeoffsetunits [ncgi::value condition_.ClickthroughTimeFromEventUnits_]
			set timeoffsetpastfuture [ncgi::value condition_.ClickthroughTimeFromEventPastFuture_]
			set ClickthroughAggregationType [ncgi::value condition_.ClickthroughAggregationType_]
			#puts "timeoffsetvalue: '$timeoffsetvalue'"
			#puts "timeoffsetunits: '$timeoffsetunits'"
			#puts "timeoffsetpastfuture: '$timeoffsetpastfuture'"
			#puts "ClickthroughAggregationType: '$ClickthroughAggregationType'"
			
			if {[string compare [ncgi::value condition_.ClickthroughAction_] "clicked_on"] == 0} {	
				if {[string compare [ncgi::value condition_.ClickthroughMailing_] "any_mailing"] == 0} {
					set mailingclause ""
				} else {
					set mailingclause "clicktracking_.MessageID_=[lmcgi::value_int condition_.ClickthroughMailing_] AND "
				}
				if {[string compare [ncgi::value condition_.ClickthroughUrl_] "any_url"] == 0} {
					set urlclause "clicktracking_.UrlID_ IS NOT NULL AND clicktracking_.StreamWebPageName_ IS NULL"
				} else {
					set urlclause "clicktracking_.UrlID_=[lmcgi::value_int condition_.ClickthroughUrl_] AND clicktracking_.StreamWebPageName_ IS NULL"
				}
				set clause "(${mailingclause}${urlclause})"
				set triggerdateclause "EXISTS (SELECT clicktracking_.MemberID_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause %%timeclickedclause%%)"
				#puts "clause: '$clause'"
				
				set comment [subst [translation::text {--Clickthrough Trigger: clicked on url '$clickthroughurl' in mailing '$clickthroughmailing'}]]
				
				if {$ClickthroughAggregationType == "f"} {
					append triggerdateclause " AND NOT EXISTS (SELECT clicktracking_.MemberID_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause AND %%timeclicked_lasttime_clause%%)"
					append comment " for the first time"
				}
				set triggerdateclause ($triggerdateclause)
			
			} else {
				# no other options implemented yet
			}


        } elseif { [ncgi::value current_tab] == "Clickstream" } {
			#puts "processing for insert-trigger-new-do - Clickstream"
			set clickstream [ncgi::value condition_.ClickstreamAction_]
			set clickstreampage [ncgi::value condition_.ClickstreamPage_]
			set clickstreammailing [ncgi::value condition_.ClickstreamMailing_]
			#puts "clickstream: '$clickstream'"
			#puts "clickstreampage: '$clickstreampage'"
			#puts "clickstreammailing: '$clickstreammailing'"
			set timeoffsetvalue [ncgi::value condition_.ClickstreamTimeFromEventValue_]
			set timeoffsetunits [ncgi::value condition_.ClickstreamTimeFromEventUnits_]
			set timeoffsetpastfuture [ncgi::value condition_.ClickstreamTimeFromEventPastFuture_]
			set ClickstreamAggregationType [ncgi::value condition_.ClickstreamAggregationType_]
			#puts "timeoffsetvalue: '$timeoffsetvalue'"
			#puts "timeoffsetunits: '$timeoffsetunits'"
			#puts "timeoffsetpastfuture: '$timeoffsetpastfuture'"
			#puts "ClickstreamAggregationType: '$ClickstreamAggregationType'"
			
			if {[string compare [ncgi::value condition_.ClickstreamAction_] "viewed"] == 0} {	
				if {[string compare [ncgi::value condition_.ClickstreamMailing_] "any_mailing"] == 0} {
					set mailingclause ""
				} else {
					set mailingclause "clicktracking_.MessageID_=[lmcgi::value_int condition_.ClickstreamMailing_] AND "
				}
				if {[string compare [ncgi::value condition_.ClickstreamPage_] "any_page"] == 0} {
					set pageclause "clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_ IS NOT NULL"
				} else {
					set pageclause "clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_='[ncgi::value condition_.ClickstreamPage_]'"
				}
				set clause "(${mailingclause}${pageclause})"
				set triggerdateclause "EXISTS (SELECT clicktracking_.MemberID_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause %%timeclickedclause%%)"
				set comment [subst [translation::text {--Clickstream Trigger: clicked on page '$clickstreampage' in mailing '$clickstreammailing'}]]
				if {$ClickstreamAggregationType == "f"} {
					append triggerdateclause " AND NOT EXISTS (SELECT clicktracking_.MemberID_ FROM clicktracking_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND $clause AND %%timeclicked_lasttime_clause%%)"
					append comment " for the first time"
				}
				set triggerdateclause ($triggerdateclause)
			
			} else {
				# no other options implemented yet
			}

        } elseif { [ncgi::value current_tab] == "Purchase" } {
			#puts "processing for insert-trigger-new-do - Purchase"
			set PurchaseAmountComparator [ncgi::value condition_.PurchaseAmountComparator_]
			set PurchaseAmount [ncgi::value condition_.PurchaseAmount_]
			set PurchaseType [ncgi::value condition_.PurchaseType_]
			set PurchaseSkuList [ncgi::valueList condition_.PurchaseSKU_]
			set PurchasePage [ncgi::value condition_.PurchasePage_]
			set PurchaseMailing [ncgi::value condition_.PurchaseMailing_]
			set PurchaseAggregationType [ncgi::value condition_.PurchaseAggregationType_]
			#puts "PurchaseAmountComparator: '$PurchaseAmountComparator'"
			#puts "PurchaseAmount: '$PurchaseAmount'"
			#puts "PurchaseType: '$PurchaseType'"
			#puts "PurchaseSkuList: '$PurchaseSkuList'"
			#puts "PurchasePage: '$PurchasePage'"
			#puts "PurchaseMailing: '$PurchaseMailing'"
			#puts "PurchaseAggregationType: '$PurchaseAggregationType'"
			set timeoffsetvalue [ncgi::value condition_.PurchaseTimeFromEventValue_]
			set timeoffsetunits [ncgi::value condition_.PurchaseTimeFromEventUnits_]
			set timeoffsetpastfuture [ncgi::value condition_.PurchaseTimeFromEventPastFuture_]
			#puts "timeoffsetvalue: '$timeoffsetvalue'"
			#puts "timeoffsetunits: '$timeoffsetunits'"
			#puts "timeoffsetpastfuture: '$timeoffsetpastfuture'"
		
			# Sections to handle:
			# 1) amount comparison - aggregation 
			# Price or Quantity:
			if {[string compare [ncgi::value condition_.PurchaseType_] "p"] == 0} {
				set amounttypefield "clickstreamdata_.Quantity_*clickstreamdata_.UnitPrice_"
				set amounttypecomment [translation::text "(by price)"]
			} else {
				set amounttypefield "clickstreamdata_.Quantity_"
				set amounttypecomment [translation::text "(by quantity)"]
			}
			set amountcomparison "SELECT SUM($amounttypefield) FROM clicktracking_, clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_ AND clickstreamdata_.Quantity_ > 0 "
			
			# 3) page criteria
			if {[string compare [ncgi::value condition_.PurchasePage_] "any_page"] == 0} {
				set pageclause ""
			} else {
				set pageclause " AND clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_=[lyrsql::quote [ncgi::value condition_.PurchasePage_]]"
			}
			# 4) specific mailing
			if {[string compare [ncgi::value condition_.PurchaseMailing_] "any_mailing"] == 0} {
				set mailingclause ""
			} else {
				set mailingclause " AND clicktracking_.MessageID_=[lmcgi::value_int condition_.PurchaseMailing_] "
			}
			# 5) product/SKU
                        if {[llength $PurchaseSkuList] == 0 || ([llength $PurchaseSkuList] == 1 && [string length [string trim [lindex $PurchaseSkuList 0]]] == 0) } {
				set productclause ""
				set productnamecomment ""
			} else {
                if { [llength $PurchaseSkuList] == 1 } {
                    set PurchaseSku [lindex $PurchaseSkuList 0]
                    set productclause " AND clickstreamdata_.ProductSku_=[lyrsql::quote $PurchaseSku]"
                    set productnamecomment [subst [translation::text { of product [lyrsql::quote $PurchaseSku]} ]]
                } else {
                    set PurchaseSkuListQuoted {}
                    foreach PurchaseSku $PurchaseSkuList {
                        lappend PurchaseSkuListQuoted [lyrsql::quote $PurchaseSku]
                    }
                    set ProductSkuCommaList [join $PurchaseSkuListQuoted {, }]
                    set productclause " AND clickstreamdata_.ProductSku_ in ( $ProductSkuCommaList )"
                    set productnamecomment [subst [translation::text { of products $ProductSkuCommaList } ]]
                }
			}


			# 6) Aggregation type
			if {[ncgi::value condition_.PurchaseAggregationType_] == "a"} {
				set clause "((${amountcomparison} %%timeclickedclause%%${mailingclause}${productclause}${pageclause})[ncgi::value condition_.PurchaseAmountComparator_][lmcgi::value_int condition_.PurchaseAmount_])"
			} else {
				set clause "((${amountcomparison} AND %%timeclicked_currenttime_clause%%${mailingclause}${productclause}${pageclause})[ncgi::value condition_.PurchaseAmountComparator_][lmcgi::value_int condition_.PurchaseAmount_])"
			}
			set existscomparison "SELECT clickstreamdata_.Quantity_ FROM clicktracking_, clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_"
			if {( ([lmcgi::value_int condition_.PurchaseAmount_] == 0) && ([ncgi::value condition_.PurchaseAmountComparator_] == "=") )} {
				# NEED TO ALSO COUNT MEMBERS WHO HAVE NO CLICKSTREAM EVENTS THAT MATCH THIS CRITERIA
				if {[ncgi::value condition_.PurchaseAggregationType_] == "a"} {
					append clause " OR (NOT EXISTS (${existscomparison} %%timeclickedclause%%${mailingclause}${productclause}${pageclause}))"
				} else {
					append clause " OR (NOT EXISTS (${existscomparison} AND %%timeclicked_currenttime_clause%%${mailingclause}${productclause}${pageclause}))"
				}
			} else {
				if {[ncgi::value condition_.PurchaseAggregationType_] == "f"} {
					#puts "cumulative"
					append clause " AND (NOT ((${amountcomparison}${mailingclause}${productclause}${pageclause} AND %%timeclicked_lasttime_clause%%)[ncgi::value condition_.PurchaseAmountComparator_][lmcgi::value_int condition_.PurchaseAmount_])"
					append clause " OR (NOT EXISTS (${existscomparison} AND %%timeclicked_lasttime_clause%%${mailingclause}${productclause}${pageclause})))"
				}
			}
			
			if {[lmcgi::value_int condition_.PurchaseDays_] == 0} {
				set dayscomment ""
			} else {
				set dayscomment [subst [translation::text { in the last $PurchaseDays days}]]
			}
			if {[ncgi::value condition_.PurchaseAggregationType_] == "a"} {
				set cumulativecomment "(all since the last runtime)" 
			} elseif {[ncgi::value condition_.PurchaseAggregationType_] == "c"} {
				set cumulativecomment "(in cumulative total)" 
			} else {
				set cumulativecomment "(reached this cumulative total for the first time)" 
			}
			set comment [subst [translation::text {--Purchase Trigger: purchased $PurchaseAmountComparator$PurchaseAmount $amounttypecomment$productnamecomment on page '$PurchasePage' from mailing '$PurchaseMailing'$dayscomment}]]
			set triggerdateclause ($clause)
			#puts "triggerdateclause: '$triggerdateclause'"


        } elseif { [ncgi::value current_tab] == "Interest" } {
			#puts "processing for insert-trigger-new-do - Interest"
			set InterestAmountComparator [ncgi::value condition_.InterestAmountComparator_]
			set InterestAmount [ncgi::value condition_.InterestAmount_]
			set InterestType [ncgi::value condition_.InterestType_]
			set InterestPage [ncgi::value condition_.InterestPage_]
			set InterestMailing [ncgi::value condition_.InterestMailing_]
			set InterestAggregationType [ncgi::value condition_.InterestAggregationType_]
			#puts "InterestAmountComparator: '$InterestAmountComparator'"
			#puts "InterestAmount: '$InterestAmount'"
			#puts "InterestType: '$InterestType'"
			#puts "InterestPage: '$InterestPage'"
			#puts "InterestMailing: '$InterestMailing'"
			#puts "InterestAggregationType: '$InterestAggregationType'"
			set timeoffsetvalue [ncgi::value condition_.InterestTimeFromEventValue_]
			set timeoffsetunits [ncgi::value condition_.InterestTimeFromEventUnits_]
			set timeoffsetpastfuture [ncgi::value condition_.InterestTimeFromEventPastFuture_]
			#puts "timeoffsetvalue: '$timeoffsetvalue'"
			#puts "timeoffsetunits: '$timeoffsetunits'"
			#puts "timeoffsetpastfuture: '$timeoffsetpastfuture'"
			
			# Sections to handle:
			# 1) amount comparison - aggregation (can this be done? NEEDS SUBQUERY)
			if {[ncgi::value condition_.InterestType_] == "p"} {
				# Interest Points: sum interest points with a subquery
				set interestcriteria "SUM(clickstreamdata_.Points_)"
			} elseif {[ncgi::value condition_.InterestType_] == "s"} {
				# Interest Stage: find highest stage
				set interestcriteria "MAX(clickstreamdata_.Stage_)"
			} else {
				# Interest Events: count all events 
				set interestcriteria "COUNT(*)"
			}
			set amountcomparison "SELECT ${interestcriteria} FROM clicktracking_, clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_"
			# 3) page criteria
			if {[string compare [ncgi::value condition_.InterestPage_] "any_page"] == 0} {
				set pageclause ""
			} else {
				set pageclause " AND clicktracking_.UrlID_ IS NULL AND clicktracking_.StreamWebPageName_=[lyrsql::quote [ncgi::value condition_.InterestPage_]]"
			}
			# 4) specific mailing
			if {[string compare [ncgi::value condition_.InterestMailing_] "any_mailing"] == 0} {
				set mailingclause ""
			} else {
				set mailingclause " AND clicktracking_.MessageID_=[lmcgi::value_int condition_.InterestMailing_] "
			}
			
			# 6) Aggregation type
			if {[ncgi::value condition_.InterestAggregationType_] == "a"} {
				set clause "((${amountcomparison} %%timeclickedclause%%${mailingclause}${pageclause})[ncgi::value condition_.InterestAmountComparator_][lmcgi::value_int condition_.InterestAmount_])"
			} else {
				set clause "((${amountcomparison} AND %%timeclicked_currenttime_clause%%${mailingclause}${pageclause})[ncgi::value condition_.InterestAmountComparator_][lmcgi::value_int condition_.InterestAmount_])"
			}
			
			set existscomparison "SELECT clickstreamdata_.Points_ FROM clicktracking_, clickstreamdata_ WHERE [dbinfo::members_name].[dbinfo::members_memberid]=clicktracking_.MemberID_ AND clicktracking_.ClickID_=clickstreamdata_.ClickID_"
			if {( ([lmcgi::value_int condition_.InterestAmount_] == 0) && ([ncgi::value condition_.InterestAmountComparator_] == "=") )} {
				# NEED TO ALSO COUNT MEMBERS WHO HAVE NO CLICKSTREAM EVENTS THAT MATCH THIS CRITERIA
				if {[ncgi::value condition_.InterestAggregationType_] == "a"} {
					append clause " OR (NOT EXISTS (${existscomparison} %%timeclickedclause%%${mailingclause}${pageclause}))"
					#append clause " OR ((${amountcomparison} %%timeclickedclause%%${mailingclause}${pageclause}) IS NULL)"
				} else {
					append clause " OR (NOT EXISTS (${existscomparison} AND %%timeclicked_currenttime_clause%%${mailingclause}${pageclause}))"
					#append clause " OR ((${amountcomparison} AND %%timeclicked_currenttime_clause%%${mailingclause}${pageclause}) IS NULL)"
				}
			} else {
				if {[ncgi::value condition_.InterestAggregationType_] == "f"} {
					append clause " AND (NOT ((${amountcomparison}${mailingclause}${pageclause} AND %%timeclicked_lasttime_clause%%)[ncgi::value condition_.InterestAmountComparator_][lmcgi::value_int condition_.InterestAmount_])"
					append clause " OR (NOT EXISTS (${existscomparison} AND %%timeclicked_lasttime_clause%%${mailingclause}${pageclause})))"
				}
			}
			
			if {[lmcgi::value_int condition_.InterestDays_] == 0} {
				set dayscomment ""
			} else {
				set dayscomment [subst [translation::text { in the last [lmcgi::value_int condition_.InterestDays_] days}]]
			}
			if {[ncgi::value condition_.InterestType_] == "p"} {
				set typecomment [translation::text "Interest Points" ]
			} elseif {[ncgi::value condition_.InterestType_] == "e"} {
				set typecomment [translation::text "Interest Events" ]
			} else {
				set typecomment [translation::text "Interest Stage" ]
			}
			if {[ncgi::value condition_.InterestAggregationType_] == "a"} {
				set cumulativecomment "(only counting interest shown since the last runtime)" 
			} elseif {[ncgi::value condition_.InterestAggregationType_] == "c"} {
				set cumulativecomment "(counting all interest that has ever been shown)" 
			} else {
				set cumulativecomment "(counting all interest that has ever been shown, this threshold has been reached for the first time)" 
			}
			
			set comment [subst [translation::text {--Interest Trigger: reached ${InterestAmountComparator}${InterestAmount} $typecomment $cumulativecomment on page '[ncgi::value condition_.InterestPage_]' from mailing '[ncgi::value condition_.InterestMailing_]'$dayscomment}]]

			set triggerdateclause ($clause)
		
		
        } elseif { [ncgi::value current_tab] == "Survey" } {

			set comment ""
			set clause ""

			#puts "---------------------------------------------------------------"
			#puts "generating survey SQL"
			#puts "---------------------------------------------------------------"

			# Form dropdown fields:
			#puts "SurveyRespondAction: '[ncgi::value condition_.SurveyRespondAction]'"
			#puts "SurveyWebForm: '[ncgi::value condition_.SurveyWebForm]'"
			#puts "SurveyQuestionAction: '[ncgi::value condition_.SurveyQuestionAction]'"
			#puts "SurveyQuestion: '[ncgi::value condition_.SurveyQuestion]'"
			#puts "SurveyAnswerAction: '[ncgi::value condition_.SurveyAnswerAction]'"
			#puts "SurveyAnswer: '[ncgi::value condition_.SurveyAnswer]'"
			#puts "Multiple: '[ncgi::value condition_.Multiple]'"
			
			set SurveyRespondAction [ncgi::value condition_.SurveyRespondAction]
			set SurveyWebForm [ncgi::value condition_.SurveyWebForm]
			set SurveyQuestionAction [ncgi::value condition_.SurveyQuestionAction]
			set SurveyQuestion [ncgi::value condition_.SurveyQuestion]
			set SurveyAnswerAction [ncgi::value condition_.SurveyAnswerAction]
			set SurveyAnswer [ncgi::value condition_.SurveyAnswer]
			set Multiple [ncgi::value condition_.Multiple]
			set SurveyTextComparator [ncgi::value condition_.SurveyTextComparator]
			set SurveyTextValue [ncgi::value condition_.SurveyTextValue]

			# 1) responded/not_responded to any survey 
			if {$SurveyWebForm == "any_survey"} {
				if {$SurveyRespondAction == "responded_to"} {
					if {$Multiple == "n"} {
						set comment [subst [translation::text {-- Survey Trigger: responded to any survey}]]
						set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%%)"
					} elseif {$Multiple == "q"} {
						if {[ncgi::value condition_.SurveyQuestionsAnsweredValue_] != [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_]} {
							look::redirect_to_message_page "" [translation::text "You must enter an integer value for the 'This many questions' field"] "segments" 
						}
						set comment [subst [translation::text {-- Survey Trigger: responded to any survey with [ncgi::value condition_.SurveyQuestionsAnsweredComparator_] [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_] questions answered}]]
						set clause "EXISTS ( SELECT * FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND ( (SELECT COUNT(*) FROM lyrSurveyResponseAnswers ra WHERE r.ResponseID = ra.ResponseID) [ncgi::value condition_.SurveyQuestionsAnsweredComparator_] [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_] ) )"
					}
				} elseif {$SurveyRespondAction == "did_not_respond_to"} {
					set comment [subst [translation::text {-- Survey Trigger: did not respond to any survey}]]
					set clause "NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%%)"
				}
			} else {

				# 2) responded/not responded to a specific survey:
				if {$Multiple == "n"} {
					# 2a) with no extra filtering
					if {$SurveyRespondAction == "responded_to"} {
						set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]'}]]
						set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
					} elseif {$SurveyRespondAction == "did_not_respond_to"} {
						set comment [subst [translation::text {-- Survey Trigger: did not respond to survey '[segments::survey_form_name $SurveyWebForm]'}]]
						set clause "NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
					}
				} elseif {$Multiple == "q"} {
					# 2b) with number of questions answered filtering
					if {[ncgi::value condition_.SurveyQuestionsAnsweredValue_] != [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_]} {
						look::redirect_to_message_page "" [translation::text "You must enter an integer value for the 'This many questions' field"] "segments" 
					}
					set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' with [ncgi::value condition_.SurveyQuestionsAnsweredComparator_] [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_] questions answered}]]
					set clause "EXISTS ( SELECT * FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm] AND ( (SELECT COUNT(*) FROM lyrSurveyResponseAnswers ra WHERE r.ResponseID = ra.ResponseID) [ncgi::value condition_.SurveyQuestionsAnsweredComparator_] [lmcgi::value_int condition_.SurveyQuestionsAnsweredValue_] ) )"
				
				} elseif {$Multiple == "p"} {
					# 2c) with filtering on specific question
					if {$SurveyQuestionAction == "did_not_answer"} {
						#   i) did not answer a question 
						if {$SurveyQuestion == "choose_a_question"} {
							look::redirect_to_message_page "" [translation::text "You must choose a question"] "segments" 
						} else {
							set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and did not answer question '[segments::survey_question_name $SurveyQuestion]'}]]
							set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
							append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm] AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
						}
					} else {
						if {$SurveyQuestion == "choose_a_question"} {
							look::redirect_to_message_page "" [translation::text "You must choose a question"] "segments" 
						} else {
							if {$SurveyAnswer == "any_answer"} {
								if {$SurveyAnswerAction == "selected"} {
									#   ii) answered a question, with any answer selected 
									set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and selected any answer to question '[segments::survey_question_name $SurveyQuestion]'}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
								} else {
									#   ii) answered a question, with any answer not selected (what will this mean?)  (error page?)
									set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and did not select any answer to question '[segments::survey_question_name $SurveyQuestion]'}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
									append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
								}
							} elseif {$SurveyAnswer == "any_multiple_choice"} {
								if {$SurveyAnswerAction == "selected"} {
									#   iii) answered a question, with any multiple-choice answer selected 
									set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and selected any multiple-choice answer to question '[segments::survey_question_name $SurveyQuestion]'}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.AnswerID IS NOT NULL AND ra.FreeFormAnswer IS NULL)"
								} else {
									#   iii) answered a question, with any multiple-choice answer not selected 
									set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and answered question '[segments::survey_question_name $SurveyQuestion]' but did not select any multiple-choice answer}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
									append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.AnswerID IS NOT NULL AND ra.FreeFormAnswer IS NULL)"
								}
							
							} elseif {$SurveyAnswer == "freeform"} {
								if {$SurveyAnswerAction == "selected"} {
									#   iv) answered a question, with a free-form text answer selected 
									if {$SurveyTextComparator == "is_not_null"} {
										set textcomment ""
										set textclause ""
									} elseif {$SurveyTextComparator == "contains"} {
										set textcomment [subst [translation::text { which contains '$SurveyTextValue'}]]
										set textclause " AND ra.FreeFormAnswer LIKE [lyrsql::quote %[ncgi::value condition_.SurveyTextValue]%] "
									} elseif {$SurveyTextComparator == "not_contains"} {
										set textcomment [subst [translation::text { which does not contain '$SurveyTextValue'}]]
										set textclause " AND ra.FreeFormAnswer NOT LIKE [lyrsql::quote %[ncgi::value condition_.SurveyTextValue]%] "
									} elseif {$SurveyTextComparator == "endswith"} {
										set textcomment [subst [translation::text { which ends with '$SurveyTextValue'}]]
										set textclause " AND ra.FreeFormAnswer LIKE [lyrsql::quote %[ncgi::value condition_.SurveyTextValue]] "
									} elseif {$SurveyTextComparator == "beginswith"} {
										set textcomment [subst [translation::text { which begins with '$SurveyTextValue'}]]
										set textclause " AND ra.FreeFormAnswer LIKE [lyrsql::quote [ncgi::value condition_.SurveyTextValue]%] "
									}
									set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and entered a free-form text answer to question '[segments::survey_question_name $SurveyQuestion]'}]]
									append comment $textcomment
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.FreeFormAnswer IS NOT NULL $textclause)"
								} else {
									#   iv) answered a question, with a free-form text answer not selected 
									set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and answered question '[segments::survey_question_name $SurveyQuestion]' but did not enter a free-form text answer}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
									append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.FreeFormAnswer IS NOT NULL)"
								}
							} else {
								if {$SurveyAnswerAction == "selected"} {
									# Answered a particular multiple-choice answer to a particular question   
									set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and selected the answer '[segments::survey_answer_name $SurveyAnswer]' to the question '[segments::survey_question_name $SurveyQuestion]'}]]
									append clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.AnswerID = [lmcgi::value_int condition_.SurveyAnswer])"
								} else {
									# Did not answered a particular multiple-choice answer to a particular question   
									set comment [subst [translation::text {-- Survey Trigger: responded to survey '[segments::survey_form_name $SurveyWebForm]' and did not select the answer '[segments::survey_answer_name $SurveyAnswer]' to the question '[segments::survey_question_name $SurveyQuestion]'}]]
									set clause "EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
									append clause " AND NOT EXISTS (SELECT r.MemberID FROM lyrSurveyResponse r, lyrSurveyResponseAnswers ra WHERE [dbinfo::members_name].[dbinfo::members_memberid] = r.MemberID %%responsetimeclause%% AND r.ResponseID = ra.ResponseID AND r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm]  AND ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion] AND ra.AnswerID = [lmcgi::value_int condition_.SurveyAnswer])"
								}

							}
						}
					}
				}
			}

			set triggerdateclause ($clause)
              } 
        

		
		
		
		# STEP 3) 
		# Create the full trigger clause to put into the segment query
		#
		# The full trigger will have this structure:  ( (offset(datetime) > last_runtime) AND (offset(datetime) <= this_runtime) )
		# 
		
		if {$triggerdateclause != ""} {
			#puts "building trigger clause"
			# DEBUG
			set last_runtime "'2003-01-01'"
			set this_runtime "'2003-02-01'"
			if {$dateanniversary == "anniversary"} {
				set anniversary 1
			} else {
				set anniversary 0
			}
			if {[regexp {(%%timeclickedclause%%)} $triggerdateclause] || [regexp {%%timeclicked_lasttime_clause%%} $triggerdateclause] || [regexp {(%%timeclicked_currenttime_clause%%)} $triggerdateclause] || [regexp {(%%responsetimeclause%%)} $triggerdateclause] } {
			
				# Some triggers should fire only the first time a threshold is passed, so it requires a clause that excludes members who previously qualified for that trigger, 
				# and the only way to do that is to do the same calculation BEFORE the lastruntime and then exclude those members that met that criteria.
				if {[regexp {%%timeclicked_lasttime_clause%%} $triggerdateclause]} {
					#puts "found %%timeclicked_lasttime_clause%%"
					#puts "before: '$triggerdateclause'" 
					# get the syntax for the 
					set triggerfieldname "clicktracking_.TimeClicked_"
					set lasttime_only_clause [dbinfo::queryparser_create_runtime_comparison_syntax $triggerfieldname $timeoffsetvalue $timeoffsetunits $timeoffsetpastfuture $last_runtime $this_runtime $anniversary "" 1]
					#puts "substitution: '$lasttime_only_clause'"
					regsub -all {(%%timeclicked_lasttime_clause%%)} $triggerdateclause $lasttime_only_clause triggerdateclause
					#puts "after: '$triggerdateclause'" 
				}
				# Some triggers should fire only the first time a threshold is passed, so it requires an aggregation up to the current runtime
				if {[regexp {%%timeclicked_currenttime_clause%%} $triggerdateclause]} {
					#puts "found %%timeclicked_currenttime_clause%%"
					#puts "before: '$triggerdateclause'" 
					# get the syntax for the 
					set triggerfieldname "clicktracking_.TimeClicked_"
					set currenttime_only_clause [dbinfo::queryparser_create_runtime_comparison_syntax $triggerfieldname $timeoffsetvalue $timeoffsetunits $timeoffsetpastfuture $last_runtime $this_runtime $anniversary "" 0 1]
					#puts "substitution: '$currenttime_only_clause'"
					regsub -all {(%%timeclicked_currenttime_clause%%)} $triggerdateclause $currenttime_only_clause triggerdateclause
					#puts "after: '$triggerdateclause'" 
				}
				
				# Each trigger clause will have this structure in it:  ( (offset(datetime) > last_runtime) AND (offset(datetime) <= this_runtime) )
				if {[regexp {(%%timeclickedclause%%)} $triggerdateclause]} {
					# 1) look for the special tag %%timeclickedclause%%, which is a placeholder for doing the date offset on the clicktracking_.timeclicked_ field inside a subquery
					#puts "found %%timeclickedclause%%"
					set triggerfieldname "clicktracking_.TimeClicked_"
					set offsetclause " AND "
					append offsetclause [dbinfo::queryparser_create_runtime_comparison_syntax $triggerfieldname $timeoffsetvalue $timeoffsetunits $timeoffsetpastfuture $last_runtime $this_runtime $anniversary]
					regsub -all {(%%timeclickedclause%%)} $triggerdateclause $offsetclause triggerdateclause
				}
				if {[regexp {(%%responsetimeclause%%)} $triggerdateclause]} {
					# 2) look for the special tag %%responsetimeclause%%, which is a placeholder for doing the date offset on the r.ResponseTime field inside a subquery
					#puts "found %%responsetimeclause%%"
					set triggerfieldname "r.ResponseTime"
					set offsetclause " AND "
					append offsetclause [dbinfo::queryparser_create_runtime_comparison_syntax $triggerfieldname $timeoffsetvalue $timeoffsetunits $timeoffsetpastfuture $last_runtime $this_runtime $anniversary]
					regsub -all {(%%responsetimeclause%%)} $triggerdateclause $offsetclause triggerdateclause
				}
				if {$comment != ""} {
					ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				}
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$triggerdateclause\n"
			} else {
				# 2) otherwise, do the date offset around the triggerdateclause, because it returns a single date
				if {$comment != ""} {
					ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n$comment"
				}
				set fulltriggerclause [dbinfo::queryparser_create_runtime_comparison_syntax $triggerdateclause $timeoffsetvalue $timeoffsetunits $timeoffsetpastfuture $last_runtime $this_runtime $anniversary]
				ncgi::setValue subsets_.ClauseWhere_ "[ncgi::value subsets_.ClauseWhere_] \n($fulltriggerclause)\n"
			}

		}

    }


    # the tab definitions are a list of paired values, the first value being the text name
    # of the tab, and the 2nd value of the pair being the code that creates the html for
    # that tab.  You should assign your html to the $this_tab variable, and be sure to set
    # $fields_on_this_tab with the names of the fields that this tab makes editable,
    # so that the values of the undisplayed fields can be retained in hidden fields

    if { $triggered_segment == 1} { 
        set help_url "segments__new_triggered_se.html" 
    } else {
        set help_url "segmentessentials.html"
    }
        
    set tab_essentials "Essentials $help_url"
    lappend tab_essentials  {

            misc::get_selectable_fields text_fields number_fields date_fields [ncgi::value subsets_.ClauseFrom_]

            set additional ""
            set disabled ""
            if {![ncgi::empty key_field_value]} {
                if {[expr [lyrsql::select_value "SELECT count(*) FROM moderate_ WHERE SubsetID_= [ncgi::value key_field_value] AND Type_=[lyrsql::quote triggered]"]] > 0} {
                    append this_tab [text::hidden_fields "subsets_.Name_"]
                    set additional "&nbsp;&nbsp;This segment is in use by a triggered mailing, renaming is not permitted. Please copy the segment to reuse it."
                    set disabled "disabled"
                }
            }
            append this_tab [look::dialogbox_row_fillout_line "Segment name" "subsets_.Name_" 50 60 {valid_segment_name unique_for_list} $additional $disabled]
            append this_tab [look::dialogbox_row_fillout_line "Description" "subsets_.Desc_" 50 60 {notempty notwhitespace}]

			set button_html ""
			append button_html [subst {
			    <table cellspacing="0" cellpadding="0" border="0" width="600">
				<tr>
				<td valign="middle" align="left" width="180">
				<input [translation::inputTagSubmitImage "Insert Clause"] name="insert_condition">&nbsp;}]

			if {[ncgi::value triggered_segment] != ""} {
				append button_html [subst {<input [translation::inputTagSubmitImage "Insert Trigger"] name="insert_trigger">}] 
			}
			
			
			append button_html [subst {
				</td>
				<td valign="middle" align="left" width="420">
				<input [translation::inputTagSubmitImage and] name="append_and">
				<input [translation::inputTagSubmitImage or] name="append_or">
				<input [translation::inputTagSubmitImage not] name="append_not">
				<input [translation::inputTagSubmitImage "open parentheses"] name="append_open_paren">
				<input [translation::inputTagSubmitImage "close parentheses"] name="append_close_paren">
				<input [translation::inputTagSubmitImage "Clear"] name="clear_entire">
				</td>
				</tr>
				</table>
			}]
                
                        look::add_mailstream_dropdown this_tab "subsets_.MailStreamID_" "Mail stream" 
			append this_tab [look::dialogbox_row "" $button_html]

			if { [segments::allow_segment_level] == 0 } { # full
				append this_tab [look::dialogbox_row "Summary" [look::light_table_border [text::display_sql_line_comments [ncgi::value "subsets_.ClauseWhere_"]] 1 0]]
                append this_tab [look::dialogbox_row_fillout_paragraph "Query" "subsets_.ClauseWhere_" [ncgi::value QueryFieldHeight 12] 68 {} { sql_where_clause_is_secure_and_not_empty } ]

                if { [ncgi::value QueryFieldHeight 12] > 12 } {
                    set show_less_button [subst {<input [translation::inputTagSubmitImage "Show Less"] name="show_less_text">}]
                } else {
                    set show_less_button ""
                }

                append this_tab [look::dialogbox_row "" [subst {
                    $show_less_button 
                    <input [translation::inputTagSubmitImage "Show More"] name="show_more_text">
                }] ""]



            } else {
                append this_tab [look::dialogbox_row "Summary" [look::light_table_border [regsub -all "\n" [ncgi::value "subsets_.ClauseWhere_"]  "<br>" ] 0]]
                append this_tab [text::hidden_fields {subsets_.ClauseWhere_}]
            }
            
			set fields_on_this_tab {Name_ Desc_ ClauseWhere_ MailStreamID_}
    }


    set tab_advanced {
        "Advanced" 
        "segmentadvanced.html"
        {
            set pro_segments_allowed [security::pro_segments_allowed]
            set skip_disclaimered_menus [server_settings::fetch_cluster_setting HideDisclaimerMenus]
            if {!$pro_segments_allowed} {
                if {$skip_disclaimered_menus} {
                    append this_tab "<br />&nbsp;&nbsp;&nbsp;[translation::text "No advanced options available."]<br /><br />"
                } else {
                    # show disclaimer
                    append this_tab [look::dialogbox_row_fillout_line "Join other tables" "subsets_.ClauseFrom_" 77 4096 {} "<br>[security::pro_segments_disclaimer]" [security::isable pro_segments_allowed]]
                    append this_tab [look::dialogbox_row_fillout_line "Columns to display" "subsets_.ClauseSelect_" 77 4096 {} "<br>[security::pro_segments_disclaimer]" [security::isable pro_segments_allowed]]
                    append this_tab [look::dialogbox_row_fillout_line "Sorting" "subsets_.ClauseOrderBy_" 77 {} {} "<br>[security::pro_segments_disclaimer]" [security::isable pro_segments_allowed]]
                    append this_tab [look::dialogbox_row_fillout_line "After SELECT" "subsets_.ClauseAfterSelect_" 77 {} {} "<br>[security::pro_segments_disclaimer]" [security::isable pro_segments_allowed]]
                }
                ncgi::setValue subsets_.ClauseForm_ ""
                ncgi::setValue subsets_.ClauseSelect_  ""
                ncgi::setValue subsets_.ClauseOrderBy_ ""
                ncgi::setValue subsets_.ClauseAfterSelect_ ""
            } else {
                append this_tab [look::dialogbox_row_fillout_line "Join other tables" "subsets_.ClauseFrom_" 77 4096 {}]
                append this_tab [look::dialogbox_row_fillout_line "Columns to display" "subsets_.ClauseSelect_" 77 4096 {}]
                append this_tab [look::dialogbox_row_fillout_line "Sorting" "subsets_.ClauseOrderBy_" 77 {} {}]
                append this_tab [look::dialogbox_row_fillout_line "After SELECT" "subsets_.ClauseAfterSelect_" 77 {} {}]
            }
            set fields_on_this_tab {ClauseFrom_ ClauseOrderBy_ ClauseSelect_ ClauseAfterSelect_}
        }
    }
    
    set tab_boundaries {
        "Boundaries" 
        "segmentboundaries.html"
        {
            set pro_segments_allowed [security::pro_segments_allowed]
            set skip_disclaimered_menus [server_settings::fetch_cluster_setting HideDisclaimerMenus]
            if {!$pro_segments_allowed} {
                if {$skip_disclaimered_menus} {
                    append this_tab "<br />&nbsp;&nbsp;&nbsp;[translation::text "No boundaries options available."]<br /><br />"
                } else {
                    # show disclaimer
                    append this_tab [look::dialogbox_row "Pull only normal members" "<input disabled type=\"radio\">&nbsp;[translation::text yes]&nbsp;&nbsp;<input disabled type=radio>&nbsp;[translation::text no]&nbsp;&nbsp;&nbsp;<font [htmltag::font_face] size=1>[security::pro_segments_disclaimer]</font>" ]
                    append this_tab [look::dialogbox_row "Pull only members receiving regular email" "<input disabled type=\"radio\">&nbsp;[translation::text yes]&nbsp;&nbsp;<input disabled type=radio>&nbsp;[translation::text no]&nbsp;&nbsp;&nbsp;<font [htmltag::font_face] size=1>[security::pro_segments_disclaimer]</font>" ]
                    append this_tab [look::dialogbox_row "Pull only this list's members" "<input disabled type=\"radio\">&nbsp;[translation::text yes]&nbsp;&nbsp;<input disabled type=radio>&nbsp;[translation::text no]&nbsp;&nbsp;&nbsp;<font [htmltag::font_face] size=1>[security::pro_segments_disclaimer]</font>" ]
                }
                ncgi::setValue subsets_.AddWhereMemberType_ F
                ncgi::setValue subsets_.AddWhereSubType_  F
                ncgi::setValue subsets_.AddWhereList_ F
            } else {
                append this_tab [look::dialogbox_row_fillout_yes_no "Pull only normal members" "subsets_.AddWhereMemberType_" {} "<BR>[security::pro_segments_disclaimer]"]
                append this_tab [look::dialogbox_row_fillout_yes_no "Pull only members receiving regular email" "subsets_.AddWhereSubType_" {} "<BR>[security::pro_segments_disclaimer]"]
                append this_tab [look::dialogbox_row_fillout_yes_no "Pull only this list's members" "subsets_.AddWhereList_" {} "<BR>[security::pro_segments_disclaimer]"]
            }
            set fields_on_this_tab {AddWhereSubType_ AddWhereMemberType_ AddWhereList_}
        }
    }
    
    set tab_definitions [list $tab_essentials $tab_advanced $tab_boundaries]
    
    if { [segments::allow_segment_level] == 0 } { # full
        set tab_definitions [list $tab_essentials $tab_advanced $tab_boundaries]
    } else {
        set tab_definitions [list $tab_essentials]
    }

    # list the field names, and optionally the 2nd value in the pair is the default value for that
    # field, which is used when creating a new item of this type
    set fields_and_defaults {
        {Name_}
        {Desc_}
        {List_ [security::current_list]}
        {MailStreamID_ 0}
        {ClauseWhere_}
        {ClauseFrom_}
        {ClauseOrderBy_}
        {ClauseSelect_}
        {ClauseAfterSelect_}
        {AddWhereSubType_ T}
        {AddWhereMemberType_ T}
        {AddWhereList_ T}
	{Type_ [segments::GetSegmentType]}
    }


    # the name of the table that we'll be reading from and writing to
    set table_name "subsets_"

    # the name of the primary key field
    set key_field_name "SubsetID_"

    # the URL to send the user once they've finished with this builder
    set end_url [segments::getEndUrl "/segments/?sq=[ncgi::value sq]&viewtable_type=[ncgi::value viewtable_type]"]

    # the general section in this application this builder is in, so that message pages
    # can be displayed with the right highlighted tab
    set section "segments"

    # the names of any read-only fields, that are to be preserved in hidden fields. Usually,
    # these all have default values that the user then can't change, but sometimes is allowed
    # to see.
    #set read_only_fields {ServerAdm_ SiteAdmin_ Site_}
    set read_only_fields {List_ endUrl_ QueryFieldHeight viewtable_type sq}

    # call the save/edit/load function, and return the HTML it creates
    return [look::save_edit_load $table_name $key_field_name $fields_and_defaults $end_url $section $read_only_fields $tab_definitions]
}


proc segments::getEndUrl { {default "/segments/"} } {

	 if {[ncgi::value "docs_.endUrl_"] == ""} {
	 	 if {[ncgi::value "subsets_.endUrl_"] == ""} {
			return $default  
		 }	else {
			return [ncgi::value "subsets_.endUrl_"]
		 }
	 } else {
		return [ncgi::value "docs_.endUrl_"]
	 }
}


proc segments::GetSegmentType {} {
    if {[ncgi::value triggered] == ""} {
		return "normal"
	} else {
		return "triggered"
	}
}


##
# segments::page_index --- /segments/index.tml main proc
#
# DESCRIPTION
#
# Makes the html table of available segments for the /segments/index.tml page
#
# PROTOTYPE
#
# [proc segments::page_index {}]
#
# EXAMPLE
#
# [
# proc segments::page_index
# ]
##
proc segments::page_index {} {

    set nameSpaceName [ncgi::value nsn]

    lmcgi::define_cookie $nameSpaceName max 20
    lmcgi::define_cookie $nameSpaceName skip 0
    lmcgi::define_cookie $nameSpaceName ls ALL
    lmcgi::define_cookie $nameSpaceName viewtable_type [ncgi::value viewtable_type all]
    lmcgi::define_cookie $nameSpaceName sq [ncgi::value sq]

    # define what columns should be displayed, and in what left-to-right order
    set heading_order {Name_ Desc_ Action_}

    # set the default sort order for this table view, if none is already set, or restore the user's previous setting
    look::viewtable_restore_user_orderby_preference "segment_index" "Name_ ASC"

    set q [ncgi::value q]
    lmcgi::set_cookie $nameSpaceName q $q

    next_previous::set_default_max 20

    set sqlClause ""
        
    if {[ncgi::value viewtable_type]  == "triggered" } {		
       set sqlClause "AND subsets_.Type_ = 'triggered'"
    }
    
    if {[ncgi::value viewtable_type]  == "nontriggered" } {
       set sqlClause "AND subsets_.Type_ <> 'triggered'"
    }

    # get the data for this table
    set sql "select Name_, SubsetID_, Desc_ from subsets_"
    set where " where List_=[lyrsql::quote [security::current_list]] $sqlClause"
    set orderby " ORDER BY [lmcgi::value_orderby]"

    if {$q!=""} {
        append where " AND " "([misc::setupWhereClause $heading_order $q])" 
    }

    if {[ncgi::value sq]!=""} {
        if { [ncgi::value sq] == [ncgi::decode #] } { 
            append where " AND " "(Name_  LIKE '\[0-9\]%' ) "
        } elseif {[ncgi::value sq] == [ncgi::decode $]} {
            append where " AND " "(Name_  LIKE '\[!-_#$^&*+=|/~`?\]%')"
        } elseif {[ncgi::value sq] == "ALL"} {
    
        } else {	
            append where " AND " "(Name_  LIKE '[string tolower [ncgi::value sq ]]%' OR Name_  LIKE '[string toupper [ncgi::value sq ]]%')"
        } 
    } 

    append sql $where $orderby
    
    lyrsql::select "$sql" results [ncgi::value max 20] [ncgi::value skip 0]

    lmcgi::set_cookie $nameSpaceName show_next $results(show_next)
    lmcgi::set_cookie $nameSpaceName show_prev $results(show_prev)
    lmcgi::set_cookie $nameSpaceName num_rows $results(num_rows)

    set action_defs {}
    set click_defs {}
    if { [segments::allow_segment_level] != 2 } { # != none
        # define the action buttons
        lappend action_defs {"Test" "/segments/test.tml?id=[lindex $results(subsetid_) $eachrow]&sq=[ncgi::encode [ncgi::value sq]]&viewtable_type=[ncgi::value viewtable_type]&sb=1"} {"Copy" "/segments/copy.tml?id=[lindex $results(subsetid_) $eachrow]&sq=[ncgi::encode [ncgi::value sq]]&viewtable_type=[ncgi::value viewtable_type]"} {"Delete" "/segments/delete.tml?id=[lindex $results(subsetid_) $eachrow]&sq=[ncgi::encode [ncgi::value sq]]&viewtable_type=[ncgi::value viewtable_type]"}
        
        # rewrite the name_ column to HREF to an edit page
        lappend click_defs {Name_ "Edit Segment" "/segments/edit.tml?id=[lindex $results(subsetid_) $eachrow]&sq=[ncgi::encode [ncgi::value sq]]&viewtable_type=[ncgi::value viewtable_type]"}
    }
    look::add_action_column results $action_defs
    look::make_column_clickable results $click_defs

    # default what text labels should go with what fields
    array set heading_labels "Name_ {Segment Name} Desc_ Description"
    
    # define the HTML percentage of each column (note: should add to 100%)
    array set column_width "Name_ 30 Desc_ 50 Action_ 20"
    
    # define what columns should have the sortable icon displayed next to them
    set sortable {Name_ Desc_}

    if { [segments::allow_segment_level] != 2 } { # != none
        # set the filename for the CSV export file
        set csv_name "[security::current_list]_segments.csv"
    
        # set the complete SQL query needed to export this table to a CSV file
        set csv_select "$sql"
    } else {
        set csv_name ""
        set csv_select ""
    }

    # set the URL needed to get back to this page, keeping any settings we might want to refresh this table
    # (note that this URL will have appended to it anything that the viewtable needs to retain its own state)
    set base_url "[security::vtable_function_url segments::page_index segments $nameSpaceName]&viewtable_type=[ncgi::value viewtable_type]"

    if { [ncgi::value sq] != "" } {
        append base_url "&sq=[ncgi::encode [ncgi::value sq ALL]]&ls=[ncgi::value ls ALL]"
    }

    set help_url {}

    set additional(action_column) {test copy delete}
    set additional(css) viewtable.css
    set html [look::display_viewtable results $results(column_names) $results(num_rows) heading_labels $heading_order $sortable column_width $base_url $csv_name $csv_select $help_url additional]
    if {[ncgi::value sq]!="[ncgi::value ls]"} {
        lmcgi::set_cookie $nameSpaceName ls [ncgi::value sq]
    }
    return $html

}

##
# segments::page_test --- /segments/test.tml main proc
#
# DESCRIPTION
#
# Makes the html table of a test of a given segment for the /segments/test.tml page
#
# PROTOTYPE
#
# [proc segments::page_test {}]
#
# EXAMPLE
#
# [
# proc segments::page_test
# ]
##
proc segments::page_test {} {

    # set the default sort order for this table view, if none is already set, or restore the user's previous setting
    look::viewtable_restore_user_orderby_preference "segment_test" "memberid_ ASC"
    set nameSpaceName [ncgi::value nsn]
    lmcgi::define_cookie $nameSpaceName max 20
    lmcgi::define_cookie $nameSpaceName skip 0

    set SubsetID [lmcgi::value_int id]
    
    set statement "SELECT SubsetID_, Name_, Desc_, ClauseSelect_, ClauseFrom_, ClauseWhere_, ClauseAfterSelect_, ClauseOrderBy_, AddWhereList_, AddWhereMemberType_, AddWhereSubType_, NumTestRecords_ FROM subsets_ WHERE SubsetID_=$SubsetID"

    lyrsql::select_row $statement kv_array

    set clausewhere $kv_array(clausewhere_)

    if { [dbinfo::is_mssql] } {
        regsub -all {\/\*currentdatetime\*\/.*?\/\*endcurrentdatetime\*\/} $clausewhere "/*currentdatetime*/CAST([lyrsql::quote [date::clockToSQLDateTime]] AS datetime)/*endcurrentdatetime*/" clausewhere
    } else {
        regsub -all {\/\*currentdatetime\*\/.*?\/\*endcurrentdatetime\*\/} $clausewhere "/*currentdatetime*/[lyrsql::quote [date::clockToSQLDateTime]]/*endcurrentdatetime*/" clausewhere
    }

    set crt [ncgi::value CurrentRuntime_]
    set prt [ncgi::value PreviousRuntime_]
    if {$crt != ""} {
            set clausewhere [dbinfo::queryparser_set_this_runtime $clausewhere [lyrsql::quote $crt] ]
    }
    if {$prt != ""} {
            set clausewhere [dbinfo::queryparser_set_last_runtime $clausewhere [lyrsql::quote $prt] ]
    }
    set kv_array(clausewhere_) $clausewhere
	
    set sql_parts [misc::segment_create_sql_from_kv kv_array]

    set sql [lindex $sql_parts 0]
    set count_statement [lindex $sql_parts 1]
    set html_statement [lindex $sql_parts 2]
    set html_count_statement [lindex $sql_parts 3]

    next_previous::set_default_max 20
	
    lmcgi::define_cookie segmenttesttable max 20
    lmcgi::define_cookie segmenttesttable skip 0

    set skip [ncgi::value skip]
    set max [ncgi::value max]

    set sql_error {}	
    if {[catch { lyrsql::select $sql results [ncgi::value max] [ncgi::value skip] } msg]} {
        set sql_error $msg
    }

    if {[string length $sql_error] > 0} {
        # try to strip LM specific info from the error
        regexp {(Database error information.+?)-+} $sql_error match parsed_sql_error
        if {[string length $parsed_sql_error] == 0} {
                # if the stripping effort failed, go back to the older method
                regsub -nocase "TclProc_sqlexecute failed because SqlExecute threw a SqlClassException:" $sql_error "" parsed_sql_error
                regsub -nocase "dbsqlexec.*failed" $parsed_sql_error "" parsed_sql_error
        }     
        return [look::dialogbox_row "Error text" [look::light_table_border [string trim $parsed_sql_error]]]
    } 

    lmcgi::set_cookie segmenttesttable show_next $results(show_next)
    lmcgi::set_cookie segmenttesttable show_prev $results(show_prev)
    lmcgi::set_cookie segmenttesttable num_rows $results(num_rows)
	    
    # set the default sort order for this table view, if none is already set
    set MemberIDColumnName [dbinfo::members_memberid]

    ncgi::setDefaultValue orderby "$MemberIDColumnName ASC"

    # set the default number of items to display in a table
    next_previous::set_default_max 20

    # define the HTML percentage of each column (note: should add to 100%)
    array set column_width ""

    # define what columns should have the sortable icon displayed next to them
    # jgb 2/20/02 -- cannot make any columns sortable because we do not know their case sensitive 
    #set sortable [list $MemberIDColumnName [dbinfo::members_emailaddr]]
    set sortable {}

    #set sortable $results(column_names)

    # define what columns should be displayed, and in what left-to-right order
    #set heading_order {name_ desc_ action_}
    #lappend heading_order action_
    set heading_order [concat $results(column_names) Action_]

    # set the filename for the CSV export file
    #set csv_name "allsegments-[security::current_list]-[text::today_formatted].csv"
    set csv_name "data-[security::current_list]-$kv_array(name_).csv"

    lappend action_defs {"view" "/members/show/history.tml?id=[lindex $results([string tolower [dbinfo::members_memberid]]) $eachrow]"}
	
    look::add_action_column results $action_defs


    # set the URL needed to get back to this page, keeping any settings we might want to refresh this table
    # (note that this URL will have appended to it anything that the viewtable needs to retain its own state)
    set base_url "[security::vtable_function_url  segments::page_test "segments" $nameSpaceName]&id=[ncgi::value id]&count=[ncgi::value count]&CurrentRuntime_=[ncgi::value CurrentRuntime_]&PreviousRuntime_=[ncgi::value PreviousRuntime_]"
    set help_url {}

    set additional(css) viewtable.css

    set additional(action_column) {view}

    append html [look::display_viewtable results $results(column_names) $results(num_rows) heading_labels $heading_order $sortable column_width $base_url $csv_name $sql $help_url additional]
    return $html
}


##
# segments::page_copy_do --- proc for the copy_do.tml
#
# DESCRIPTION
#
# Perform the selected segment copy - for copy_do.tml
#
# PROTOTYPE
#
# [proc segments::page_copy_do {}]
#
# EXAMPLE
#
# [
# segments::page_copy_do
# ]
##
proc segments::page_copy_do {} {

    set segment_error [validate::valid_segment_name "" [ncgi::value name_]]

    if { $segment_error=="" } {
        foreach listname [ncgi::valueList list_] {
            set this_segment_error [validate::unique_for_list subsets_ Name_ List_ $listname SubsetID_ "" "Segment Name" [ncgi::value name_]]

            if { $this_segment_error != "" } {
                append segment_error $this_segment_error "<BR>\n"
            }
        }
    }

    if { $segment_error != "" } {
        look::redirect_to_message_page "" [translation::text "There were problems on your form."] "utilities" $segment_error
        # the above proc throws out of this page so nothing else is executed
    }

    set replacementvalues(name_) [ncgi::value name_]
    set replacementvalues(desc_) [ncgi::value desc_]

    foreach listname [ncgi::valueList list_] {
        set replacementvalues(list_) $listname
        lyrsql::copy "subsets_" replacementvalues "SubsetID_=[ncgi::value id]"
    }

}

##
# segments::create_sql_from_id --- build a SQL query given a saved subset's subsetid_ value
#
# DESCRIPTION
#
# This function loads the subsets values and calls $misc::segment_create_sql_from_kv$
# to create the SQL query.
#
# 4 strings are returned as a list. They are:
# 
# * 1st string - the SQL statement
# * 2nd string - the count statement
# * 3rd string - the SQL statement with HTML commands to make it more readable on a web page
# * 4th string - the count statement with HTML commands to make it more readable on a web page
#
# PROTOTYPE
#
# [proc segments::create_sql_from_id { id }]
#
# EXAMPLE
#
# [
#    set sql_parts [segments::create_sql_from_id [ncgi::value id]]
#    set sql_statement [mf_html::quoteFormValue [lindex $sql_parts 0]]
#    set count_statement [mf_html::quoteFormValue [lindex $sql_parts 1]]
#    set html_statement [lindex $sql_parts 2]
#    set html_count_statement [lindex $sql_parts 3]
#    return [join [list $html_statement $sql_statement $count_statement] "<hr>"]
# ]
##
proc segments::create_sql_from_id { id } {
    lyrsql::select_row "SELECT * FROM subsets_ WHERE SubsetID_=[lyrsql::quote $id]" kv_array 
    return [misc::segment_create_sql_from_kv kv_array]
}

proc segments::segment_sql_from_result_row { resultsname rownum } {
    upvar $resultsname results
    foreach column $results(column_names) {
        set value [lindex $results([string tolower $column]) $rownum]
        set kv_array([string tolower $column]) $value 
    }
    set sql_parts [misc::segment_create_sql_from_kv kv_array]
    set sql [lindex $sql_parts 0]
    return $sql
}



proc segments::allow_segment_level {} {
    
#set segment_level_full 0
#set segment_level_simple 1
#set segment_level_none 2

    if {[security::is_server_admin]} {
        # server admins can always do advanced segments
        return 0
    }
    
    return [server_settings::fetch_cluster_setting SegmentPermissions]
}


proc segments::adv_segments_allowed {} {
    if {[security::is_server_admin]} {
        # server admins can always do advanced segments
        return 1
    }
    
    set level [server_settings::fetch_cluster_setting SegmentPermissions]
    if {$level == 0} {
        # a level of 0 means everyone has access to advanced segments
        return 1
    }
    
    return 0
}








# Prototype
proc segments::get_member_fields_list {} {
    # get db fields

    set tablename_lc [string tolower [::dbinfo::members_name]]
    dbinfo::get_table_info [::dbinfo::members_name] 1
    #set fields $::dbinfo::tableinfo($tablename_lc,columnnames)
	set fields [dbinfo::table_info $tablename_lc columnnames]
    
	set dbfields {"" ""}
    
    set fields_to_omit {
        appneeded_
        canapppend_
        cleanauto_
        norepro_
        notifyerr_
        notifysubm_
        numappneed_
        usernamelc_
    }
    
    foreach field [lsort $fields] {
        if {[lsearch $fields_to_omit [string tolower $field]] == -1} {
            lappend dbfields "$field" "$field"
        }
    }
    return $dbfields
}


# Prototype
proc segments::get_event_fields_list {} {
    # get db fields

    set tablename_lc [string tolower [::dbinfo::members_name]]
    dbinfo::get_table_info [::dbinfo::members_name] 1
    #set fields $::dbinfo::tableinfo($tablename_lc,columnnames)
	set fields [dbinfo::table_info $tablename_lc columnnames]
    set dbfields {"" ""}
    
    set fields_to_omit {
        appneeded_
        canapppend_
        cleanauto_
        norepro_
        notifyerr_
        notifysubm_
        numappneed_
        usernamelc_
    }
    
    foreach field [lsort $fields] {
        if {[lsearch $fields_to_omit [string tolower $field]] == -1} {
            lappend dbfields "$field" "$field"
        }
    }
    return $dbfields
}


# Prototype
proc segments::get_cumulative_event_fields_list {} {
    # get db fields

    set tablename_lc [string tolower [::dbinfo::members_name]]
    dbinfo::get_table_info [::dbinfo::members_name] 1
	#set fields $::dbinfo::tableinfo($tablename_lc,columnnames)
	set fields [dbinfo::table_info $tablename_lc columnnames]
    set dbfields {"" ""}
    
    set fields_to_omit {
        appneeded_
        canapppend_
        cleanauto_
        norepro_
        notifyerr_
        notifysubm_
        numappneed_
        usernamelc_
    }
    
    foreach field [lsort $fields] {
        if {[lsearch $fields_to_omit [string tolower $field]] == -1} {
            lappend dbfields "$field" "$field"
        }
    }
    return $dbfields
}


proc segments::get_group_types_list {} {
    return {{minimum (MIN)} MIN {maximum (MAX)} MAX {sum (SUM)} SUM {count (COUNT)} COUNT}
}


# Prototype 
proc segments::get_text_fields_list {} {
    misc::get_selectable_fields text_fields number_fields date_fields [ncgi::value subsets_.ClauseFrom_]
    return $text_fields
}


# Prototype
proc segments::get_numeric_fields_list {} {
    misc::get_selectable_fields text_fields number_fields date_fields [ncgi::value subsets_.ClauseFrom_]
    return $number_fields
}

# Prototype
proc segments::get_date_fields_list {} {
    misc::get_selectable_fields text_fields number_fields date_fields [ncgi::value subsets_.ClauseFrom_]
    return $date_fields
}

proc segments::get_mailings {} {
	if {[dbinfo::is_mssql]} {
		set sql "select Title_ + ' (id:' + cast ( MessageID_ as varchar ( 10 ) ) + ')' as Title, MessageID_ from outmail_ where Type_='list' and ( exists ( select * from lyrActiveRecips where MailingID = outmail_.MessageID_) or exists ( select * from lyrCompletedRecips where MailingID = outmail_.MessageID_)) and List_=[lyrsql::quote [security::current_list]] ORDER BY MessageID_ DESC"
	} else {
		set sql "select Title_ || ' (id:' || cast ( MessageID_ as varchar ( 10 ) ) || ')' as Title, MessageID_ from outmail_ where Type_='list' and ( exists ( select * from lyrActiveRecips where MailingID = outmail_.MessageID_) or exists ( select * from lyrCompletedRecips where MailingID = outmail_.MessageID_)) and List_=[lyrsql::quote [security::current_list]] ORDER BY MessageID_ DESC"
	}
	set choices [lyrsql::select_two_columns_as_kv $sql]
	return $choices
}

proc segments::get_mailings_choices {} {
	set choices {}
	lappend choices "[translation::text {any mailing}]" "any_mailing"
	set choices [concat $choices [segments::get_mailings]]
	return $choices
}

# optional parameter limit is the maximum number of results to get, 0=infinite
proc segments::get_urls { {limit 0} } {
	# NOTE: it would be preferable to filter out urls that haven't been used on messages from this list, by joining in clicktracking_ and members_, but the performance would probably be very bad
	set sql "select PrettyName_ as Url, UrlID_ from urls_ ORDER BY PrettyName_ ASC"
	set choices [lyrsql::select_two_columns_as_kv $sql $limit]
	return $choices
}

# optional parameter limit is the maximum number of results to get, 0=infinite
proc segments::get_url_choices { {limit 0} } {
	set choices {}
	lappend choices "[translation::text {any url}]" "any_url"
	set choices [concat $choices [segments::get_urls $limit]]
	return $choices
}

proc segments::get_clickstream_pages {} {
	set sql "select distinct StreamWebPageName_ as Name, StreamWebPageName_ as Value from clicktracking_ where StreamWebPageName_ IS NOT NULL ORDER BY StreamWebPageName_ ASC"
	set choices [lyrsql::select_two_columns_as_kv $sql]
	return $choices
}

proc segments::get_clickstream_page_choices {} {
	set choices {}
	lappend choices "[translation::text {any page}]" "any_page"
	set choices [concat $choices [segments::get_clickstream_pages]]
	return $choices
}

proc segments::get_purchase_pages {} {
	set sql "select distinct StreamWebPageName_ as Name, StreamWebPageName_ as Value from clicktracking_, clickstreamdata_ where clicktracking_.ClickID_ = clickstreamdata_.ClickID_ and clicktracking_.StreamWebPageName_ IS NOT NULL and clickstreamdata_.Quantity_>0 ORDER BY StreamWebPageName_ ASC"
	set choices [lyrsql::select_two_columns_as_kv $sql]
	return $choices
}

proc segments::get_purchase_page_choices {} {
	set choices {}
	lappend choices "[translation::text {any page}]" "any_page"
	set choices [concat $choices [segments::get_purchase_pages]]
	return $choices
}

proc segments::get_interest_pages {} {
	set sql "select distinct StreamWebPageName_ as Name, StreamWebPageName_ as Value from clicktracking_, clickstreamdata_ where clicktracking_.ClickID_ = clickstreamdata_.ClickID_ and clicktracking_.StreamWebPageName_ IS NOT NULL ORDER BY StreamWebPageName_ ASC"
	set choices [lyrsql::select_two_columns_as_kv $sql]
	return $choices
}

proc segments::get_interest_page_choices {} {
	set choices {}
	lappend choices "[translation::text {any page}]" "any_page"
	set choices [concat $choices [segments::get_interest_pages]]
	return $choices
}

proc segments::get_custom_criteria {} {
	set sql "Select criteria as Name, criteria_id as value from vw_lyris_selection_criteria order by criteria"
	set choices [lyrsql::select_two_columns_as_kv $sql]
	return $choices
}

proc segments::get_custom_criteria_choices {} {
	set choices {}
	set choices [concat $choices [segments::get_custom_criteria]]
	return $choices
}



# Prototype
proc segments::get_text_comparators_list {} {
    set comparators {}
    lappend comparators [translation::text "=  equal to"] "="
    lappend comparators [translation::text "<  less than"] "<"
    lappend comparators [translation::text ">  greater than"] ">"
    lappend comparators [translation::text "<= less than or equal to"] "<="
    lappend comparators [translation::text ">= greater than or equal to"] ">="
    lappend comparators [translation::text "<> not equal to"] "<>"
	lappend comparators [translation::text "null"] "is_null"      
	lappend comparators [translation::text "not null"] "is_not_null"
    lappend comparators [translation::text "contains"] "contains"      
    lappend comparators [translation::text "does not contain"] "not_contains"
    lappend comparators [translation::text "ends with"] "endswith"
    lappend comparators [translation::text "begins with"] "beginswith"

    ### We are adding a new comparator called Joins With
    ### which allows table joins.

    if {[ncgi::value subsets_.ClauseFrom_] != ""} {
    lappend comparators [translation::text "join with"] "joinwith"
    }

    return $comparators
}

# Prototype
proc segments::get_numeric_comparators_list {} {
    set comparators {}
    lappend comparators [translation::text "=  equal to"] "="
    lappend comparators [translation::text "<  less than"] "<"
    lappend comparators [translation::text ">  greater than"] ">"
    lappend comparators [translation::text "<= less than or equal to"] "<="
    lappend comparators [translation::text ">= greater than or equal to"] ">="
    lappend comparators [translation::text "<> not equal to"] "<>"
    lappend comparators [translation::text "null"] "is_null"      
    lappend comparators [translation::text "not null"] "is_not_null"
    
    ### We are adding a new comparator called Joins With
    ### which allows table joins.

    if {[ncgi::value subsets_.ClauseFrom_] != ""} {
    lappend comparators [translation::text "join with"] "joinwith"
    }

    return $comparators
}

# Prototype
proc segments::get_short_numeric_comparators_list {} {
    set comparators {}
    lappend comparators [translation::text "=  equal to"] "="
    lappend comparators [translation::text "<  less than"] "<"
    lappend comparators [translation::text ">  greater than"] ">"
    lappend comparators [translation::text "<= less than or equal to"] "<="
    lappend comparators [translation::text ">= greater than or equal to"] ">="
    lappend comparators [translation::text "<> not equal to"] "<>"
    
	return $comparators
}


# Prototype - need more options probably?  or leave it to the SQL?
proc segments::get_date_comparators_list {} {
    set comparators {}
    lappend comparators [translation::text ">  after"] ">"
    lappend comparators [translation::text "<  before"] "<"
	lappend comparators [translation::text ">= at or after"] ">="
	lappend comparators [translation::text "<= at or before"] "<="
	lappend comparators [translation::text "=  equal to"] "="
	lappend comparators [translation::text "null"] "is_null"      
	lappend comparators [translation::text "not null"] "is_not_null"
    
    return $comparators
}



#Prototype
proc segments::fields_to_preserve {} {
    return {
        subsets_.Name_
        subsets_.Desc_
        subsets_.List_
        subsets_.ClauseWhere_
        subsets_.ClauseFrom_
        subsets_.ClauseSelect_
        subsets_.ClauseOrderBy_
        subsets_.ClauseAfterSelect_
        subsets_.Name_
        subsets_.Desc_
        subsets_.List_
        subsets_.MailStreamID_
        subsets_.ClauseWhere_
        subsets_.ClauseFrom_
        subsets_.ClauseOrderBy_
        subsets_.ClauseSelect_
        subsets_.ClauseAfterSelect_
        subsets_.AddWhereSubType_ 
        subsets_.AddWhereMemberType_
        subsets_.AddWhereList_
        subsets_.Type_
        subsets_.endUrl_
        subsets_.Preferences_
        subsets_.OptStatus_
        subsets_.AnyOrAll_
        custom.CriteriaSelection_
        custom.UserQuery_
        custom.AndOr_
        custom.CustomQuery_
        custom.Parameters_
    }
}

proc segments::insert_conditions { {triggered_segment {}} } {

    
    
    if {[string length [lmcgi::button_pressed_list {"insert-condition-new-do"  "cancel-condition-new-do"}]] > 0} {
        # finished with insert-field wizard, so go back to where we came from
        #lmcgi::Doc_Post "/segments/new.tml"
	# figure out if this is a segment on a triggered or sequential mailing, and if so, go back to the edit page for that mailing
	if {$triggered_segment != ""} {
	    lmcgi::Doc_Post "/segments/new_triggered.tml?[lmcgi::clist_url]"
	} else {
	    lmcgi::Doc_Post "/segments/new.tml?[lmcgi::clist_url]"
	}

    }

    #puts "button pressed: '[lmcgi::which_button_pressed]'"
    #puts "tab selected: '[ncgi::value current_tab]'"
    if {([ncgi::value current_tab] == "Survey") && ([lmcgi::which_button_pressed] == "" || [lmcgi::which_button_pressed] == "refresh")} {
        #puts "was on survey page"
	ncgi::setValue "tab_survey" 1
    }
    
		#
		# Adding in if statement to re-direct to a preference builder page
		#
    
    if {[lmcgi::button_pressed "choose_preferences"]} {
    # pressed button to select recipient segments
    lmcgi::Doc_Post "/segments/choose_preferences.tml?page=[lmcgi::current_page_name]"
         
    }
    
    #
    # need to deal with the different conditions and their pages returned
    #
    if {[lmcgi::button_pressed "choose_values"]} {
    	# first need to figure out the type
    	# could be a select, Date, or Free Text type
    	set criteria_id [ncgi::value custom.CriteriaSelection_]
    	set sql "select lyris_selection_type from association_sub_type where association_sub_type_id = $criteria_id"
    	set statementType [lyrsql::select_column $sql]
    	puts $statementType
    	
    	if {$statementType == "Select"} {
    		lmcgi::Doc_Post "/segments/choose_selections.tml?page=[lmcgi::current_page_name]"
    	} elseif {$statementType == "Date"} {
    		lmcgi::Doc_Post "/segments/choose_date.tml?page=[lmcgi::current_page_name]"
    	} elseif {$statementType == "{Free text}"} {
    		lmcgi::Doc_Post "/segments/choose_text.tml?page=[lmcgi::current_page_name]"
    	}	
    }
    
    #
    # check for the chosen preference selections
    #
    if {[lmcgi::button_pressed chosen_preferences]} {
        set newdemographics {}
        foreach item [ncgi::value valrightpreferences] {
            lappend newdemographics [ncgi::decode $item]
        }
        #puts $item
        ncgi::setValue subsets_.Preferences_ $newdemographics
        ncgi::setValue "tab_preferences" 1
        
    }
    
    #
    # check for the chosen custom selections
    #
    
        if {[lmcgi::button_pressed chosen_selections]} {
        #set newdemographics {}
        set selectionValues ""
        foreach item [ncgi::value valrightselections] {
            #append newdemographics [ncgi::decode $item]
            append selectionValues [ncgi::decode $item],
            puts $selectionValues
            
        }
        #puts $item
        set length [string length $selectionValues]
        puts $length
        set selectionValues [string replace $selectionValues [expr $length - 3] $length]
        puts $selectionValues
        #ncgi::setValue subsets_.Preferences_ $newdemographics
        ncgi::setValue "tab_custom" 1
        
    }
    
    #
    # check for the chosen date selections
    #
    
        if {[lmcgi::button_pressed chosen_dates]} {
        set newdemographics {}
        foreach item [ncgi::value valrightselections] {
            lappend newdemographics [ncgi::decode $item]
        }
        #puts $item
        ncgi::setValue subsets_.Preferences_ $newdemographics
        ncgi::setValue "tab_custom" 1
        
    }
    
        #
    # check for the chosen text selections
    #
    
        if {[lmcgi::button_pressed chosen_text]} {
        set newdemographics {}
        foreach item [ncgi::value valrightselections] {
            lappend newdemographics [ncgi::decode $item]
        }
        #puts $item
        ncgi::setValue subsets_.Preferences_ $newdemographics
        ncgi::setValue "tab_custom" 1
        puts [ncgi::value custom.AndOr_]
        
    }
    
    set tab_definitions {
        {
            "Text" 
            "segments__new_segment__ins.html"
            {
                ncgi::setDefaultValue condition_.MatchCase_ ""

                misc::get_selectable_fields text_fields number_fields date_fields [ncgi::value subsets_.ClauseFrom_]
		set member_text_fields $text_fields
		set comparators [segments::get_text_comparators_list]
	   	append this_tab [look::dialogbox_row "If member text field" [mf_html::selectPlain condition_.TextFieldname_ {SIZE=1} [concat [list [translation::text "select a text field"]] [lsort $text_fields]]]]

		set new_tab "'<select name=\"condition_.TextValue_\" SIZE=1>'";
		foreach myfield [lsort $text_fields] {
		    append new_tab "+'<option value=\"$myfield\">$myfield'\n"
		}
		append new_tab "+'</select>'"
                append this_tab "<script language=\"javascript\" type=\"text/javascript\">
	   	    function rewrite( avalue ) {
                        return;
                        if (avalue.value == \"joinwith\") {
	   		    document.getElementById('TEST').innerHTML = 'Join with:'
	   		    document.getElementById('TEST2').innerHTML = $new_tab
	   		} else {
	   		    document.getElementById('TEST').innerHTML = 'This value:'
	   		    document.getElementById('TEST2').innerHTML = '<INPUT TYPE=\"text\" NAME=\"condition_.TextValue_\" VALUE=\"\" SIZE=50 MAXLENGTH=100>'
	   		}
	   	    }
	   	</script>"
		append this_tab [look::dialogbox_row_fillout_listbox "Is" "condition_.TextComparator_" $comparators 1 "onChange=\"rewrite(this)\"" ]
				append this_tab "<tr><td valign=\"middle\" align=\"right\" width=\"100\"><font size=\"1\" face=\"Verdana, Arial, Helvetica, sans-serif\"><b><SPAN ID=\"TEST\">This value:</SPAN></b></font></td>"

        	append this_tab "<td width=\"640\" x=640 valign=\"middle\" align=\"left\"><font size=1 face=\"Verdana, Arial, Helvetica, sans-serif\">"
        	append this_tab "<SPAN ID=\"TEST2\"><INPUT TYPE=\"text\" NAME=\"condition_.TextValue_\" VALUE=\"\" SIZE=50 MAXLENGTH=100></SPAN>"
                append this_tab "&nbsp;[mf_html::checkbox condition_.MatchCase_ ok]&nbsp;Match case"
		append this_tab "</font></td></tr>"

		#append this_tab [look::dialogbox_row_fillout_line "<SPAN ID=\"TEST\">This value</SPAN>" "condition_.TextValue_" 50 100]
	    }
        }
        {
            "Numeric" 
            "segments__new_segment__in-1.html"
            {
                set dbfields [segments::get_numeric_fields_list]
                set comparators [segments::get_numeric_comparators_list]
		ncgi::setValue condition_.NumericFieldname_ ""
	   	append this_tab [look::dialogbox_row "If member numeric field" [mf_html::selectPlain condition_.NumericFieldname_ {SIZE=1} [concat [list [translation::text "select a numeric field"]] [lsort $dbfields]]]]

		set new_tab "'<select name=\"condition_.NumericValue_\" SIZE=1>'";
		foreach myfield [lsort $dbfields] {
		    append new_tab "+'<option value=\"$myfield\">$myfield'\n"
		}
		append new_tab "+'</select>'"

                append this_tab "<script language=\"javascript\">
	   	    function rewrite( avalue ) {
            return;
	   	        if (avalue.value == \"joinwith\") {
	   		    document.getElementById('TEST').innerHTML = 'Join with:'
	   		    document.getElementById('TEST2').innerHTML = $new_tab
	   		} else {
	   		    document.getElementById('TEST').innerHTML = 'This value:'
	   		    document.getElementById('TEST2').innerHTML = '<INPUT TYPE=\"text\" NAME=\"condition_.NumericValue_\" VALUE=\"\" SIZE=50 MAXLENGTH=100>'
	   		}
	   	    }
	   	</script>"

		append this_tab [look::dialogbox_row_fillout_listbox "Is" "condition_.NumericComparator_" $comparators 1 "onChange=\"rewrite(this)\"" ]
		append this_tab "<tr><td valign=\"middle\" align=\"right\" width=\"100\"><font size=\"1\" face=\"Verdana, Arial, Helvetica, sans-serif\"><b><SPAN ID=\"TEST\">This value:</SPAN></b></font></td>"

        	append this_tab "<td width=\"640\" x=640 valign=\"middle\" align=\"left\"><font size=1 face=\"Verdana, Arial, Helvetica, sans-serif\">"
        			append this_tab "<SPAN ID=\"TEST2\"><INPUT TYPE=\"text\" NAME=\"condition_.NumericValue_\" VALUE=\"\" SIZE=20 MAXLENGTH=20></SPAN>"
		append this_tab "</font></td></tr>"


                #append this_tab [look::dialogbox_row_fillout_listbox "Is" "condition_.NumericComparator_" $comparators 1 ]
                #append this_tab [look::dialogbox_row_fillout_line "This number" "condition_.NumericValue_" 20 20]
            }
        }
        {
            "Date" 
            "segments__new_segment__in-2.html"
            {
                set dbfields [segments::get_date_fields_list]
                set comparators [segments::get_date_comparators_list]
                #set dateanniversary {"exact date and time" "exact_date_and_time" "exact date" "exact_date" "anniversary" "anniversary"}
                # removing anniversary from this page, since calculation is incompatible with this page layout - needs own page to specify date range, because the calculation requires a date range
                set dateanniversary [translation::listbox_choices {"exact date and time" "exact_date_and_time" "anniversary" "anniversary"}]
                ncgi::setValue condition_.DateFieldname_ ""
                ncgi::setValue condition_.DateComparator_ ">"
                ncgi::setValue condition_.DateValue_ "yyyy-mm-dd"
                append this_tab [look::dialogbox_row_fillout_listbox "If this" "condition_.DateAnniversary_" $dateanniversary 1 ]
                append this_tab [look::dialogbox_row "In this field" [mf_html::selectPlain condition_.DateFieldname_ {SIZE=1} [concat [list [translation::text "select a date field"]] [lsort $dbfields]]]]
                append this_tab [look::dialogbox_row_fillout_listbox "Is" "condition_.DateComparator_" $comparators 1 ]
                append this_tab [look::dialogbox_row_fillout_date "This date" "condition_.DateValue_" 20 20]
            }
        }
        {
            "Action" 
            "segments__new_segment__in-3.html"
            {
                if {[security::purchase_tracking_allowed]} {
                    set actions [translation::listbox_choices {"opened" "opened" "did not open" "did_not_open" "clicked on any url in" "clicked_on_any_url_in" "did not click on any url in" "did_not_click_on_any_url_in" "visited from" "visited_from" "did not visit from" "did_not_visit_from" "purchased from" "purchased_from" "did not purchase from" "did_not_purchase_from"}]
                } else {
                    set actions [translation::listbox_choices {"opened" "opened" "did not open" "did_not_open" "clicked on any url in" "clicked_on_any_url_in" "did not click on any url in" "did_not_click_on_any_url_in" "visited from" "visited_from" "did not visit from" "did_not_visit_from"}]
                }
                ncgi::setValue condition_.EndDateValue_ "yyyy-mm-dd"
                if {[security::pro_content_allowed]} {
                    append this_tab [look::dialogbox_row_fillout_listbox "If list member" "condition_.Action_" $actions 1 ]
					append this_tab [look::dialogbox_row "This mailing" [mf_html::select condition_.ActionMailing_ {SIZE=1} [segments::get_mailings_choices]]]
                } else {
                    append this_tab [look::dialogbox_row_fillout_listbox "If list member" "blank" "" 1 {} {} "<BR>[security::pro_content_disclaimer]"]
		            append this_tab [look::dialogbox_row_fillout_listbox "This mailing" "blank" "" 1 {} {} "<BR>[security::pro_content_disclaimer]"]
                }
		        append this_tab [look::dialogbox_row_fillout_date "Before this date (optional)" "condition_.EndDateValue_" 20 20]
		        append this_tab [look::dialogbox_row_fillout_line "In the previous X days (optional)" "condition_.Days_" 5 5]
            }
        }
        {
            "Clickthrough" 
            "segments__new_segment__in-4.html"
            {
                set actions [translation::listbox_choices {"clicked on" "clicked_on" "did not click on" "did_not_click_on"}]
				ncgi::setValue condition_.EndDateValue_ "yyyy-mm-dd"
                if {[security::pro_content_allowed]} {
                    append this_tab [look::dialogbox_row_fillout_listbox "If list member" "condition_.ClickthroughAction_" $actions 1 ]
					append this_tab [look::dialogbox_row "This URL" [mf_html::select condition_.ClickthroughUrl_ {SIZE=1} [segments::get_url_choices 1000]]]
					append this_tab [look::dialogbox_row "In this mailing" [mf_html::select condition_.ClickthroughMailing_ {SIZE=1} [segments::get_mailings_choices]]]
                } else {
                    append this_tab [look::dialogbox_row_fillout_listbox "If list member" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "This URL" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "In this mailing" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
                }
				append this_tab [look::dialogbox_row_fillout_date "Before this date (optional)" "condition_.EndDateValue_" 20 20]
				append this_tab [look::dialogbox_row_fillout_line "In the previous X days (optional)" "condition_.Days_" 5 5]
            }
        }
        {
            "Clickstream" 
            "segments__new_segment__in-5.html"
            {
                set actions [translation::listbox_choices {"viewed" "viewed" "did not view" "did_not_view" }]
				ncgi::setValue condition_.EndDateValue_ "yyyy-mm-dd"
                if {[security::pro_content_allowed]} {
                    append this_tab [look::dialogbox_row_fillout_listbox "If list member" "condition_.ClickstreamAction_" $actions 1 ]
					append this_tab [look::dialogbox_row "This page" [mf_html::select condition_.ClickstreamPage_ {SIZE=1} [segments::get_clickstream_page_choices]]]
					append this_tab [look::dialogbox_row "From this mailing" [mf_html::select condition_.ClickstreamMailing_ {SIZE=1} [segments::get_mailings_choices]]]
                } else {
                    append this_tab [look::dialogbox_row_fillout_listbox "If list member" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "This page" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "From this mailing" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
                }
				append this_tab [look::dialogbox_row_fillout_date "Before this date (optional)" "condition_.EndDateValue_" 20 20]
				append this_tab [look::dialogbox_row_fillout_line "In the previous X days (optional)" "condition_.Days_" 5 5]
            }
        }
	    {
            "Purchase" 
            "segments__new_segment__in-6.html"
            {
				ncgi::setValue condition_.PurchaseAmountComparator_ {>}
				ncgi::setValue condition_.PurchaseAmount_ 0
				ncgi::setValue condition_.EndDateValue_ "yyyy-mm-dd"
                set comparators [segments::get_short_numeric_comparators_list]
 
                set ProductSkuListOrig [lyrsql::select_column "SELECT distinct( ProductSku_ ) FROM clickstreamdata_ ORDER BY ProductSku_"]
                set ProductSkuList {}
                foreach sku $ProductSkuListOrig {
                    lappend ProductSkuList $sku
                    lappend ProductSkuList $sku
                }

                if {[security::purchase_tracking_allowed]} {
                    append this_tab [look::dialogbox_row_fillout_listbox "Member bought" "condition_.PurchaseAmountComparator_" $comparators 1 ]
                    append this_tab [look::dialogbox_row_fillout_line "This amount" "condition_.PurchaseAmount_" 10 15 ]
					append this_tab [look::dialogbox_row_fillout_radio "" "condition_.PurchaseType_" {"price" p "quantity" q} p " "]
                    append this_tab [look::dialogbox_row_fillout_listbox_multiple "Of these product codes (optional)" "condition_.PurchaseSKU_" $ProductSkuList 4 "" "" "(multiple selections allowed)"]
					append this_tab [look::dialogbox_row_fillout_date "Before this date (optional)" "condition_.EndDateValue_" 20 20]
					append this_tab [look::dialogbox_row_fillout_line "In the previous X days (optional)" "condition_.Days_" 5 5]
					append this_tab [look::dialogbox_row "On this page" [mf_html::select condition_.PurchasePage_ {SIZE=1} [segments::get_purchase_page_choices]]]
					append this_tab [look::dialogbox_row "From this mailing" [mf_html::select condition_.PurchaseMailing_ {SIZE=1} [segments::get_mailings_choices]]]
                } else {
                    append this_tab [look::dialogbox_row_fillout_listbox "Member bought" "blank" {} 1 {} {} "<BR>[security::purchase_feature_disclaimer]"]
                    append this_tab [look::dialogbox_row_fillout_line "This amount" "blank" 10 15 ]
					append this_tab [look::dialogbox_row_fillout_radio "" "blank" [translation::listbox_choices {"price" p "quantity" q}] p " "]
                    append this_tab [look::dialogbox_row_fillout_listbox_multiple "Of these product codes (optional)" "blank" "" 4 "" "" "<BR>[security::purchase_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_date "Before this date (optional)" "blank" 20 20]
					append this_tab [look::dialogbox_row_fillout_line "In the previous X days (optional)" "blank" 5 5]
					append this_tab [look::dialogbox_row_fillout_listbox "On this page" "blank" {} 1 {} {} "<BR>[security::purchase_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "From this mailing" "blank" {} 1 {} {} "<BR>[security::purchase_feature_disclaimer]"]
                }
            }
        }
	    {
            "Interest" 
            "segments__new_segment__in-7.html"
            {
				ncgi::setValue condition_.InterestAmountComparator_ {>}
				ncgi::setValue condition_.InterestAmount_ 0
				ncgi::setValue condition_.EndDateValue_ "yyyy-mm-dd"
                set comparators [segments::get_short_numeric_comparators_list]
                if {[security::interest_tracking_allowed]} {
					append this_tab [look::dialogbox_row_fillout_listbox "Member showed" "condition_.InterestAmountComparator_" $comparators 1 ]
					append this_tab [look::dialogbox_row_fillout_line "This much" "condition_.InterestAmount_" 10 15 ]
					append this_tab [look::dialogbox_row_fillout_radio "Of this type of interest" "condition_.InterestType_" [translation::listbox_choices {"interest points" p "interest stage" s "interest events" e}] p " "]
					append this_tab [look::dialogbox_row_fillout_date "Before this date (optional)" "condition_.EndDateValue_" 20 20]
					append this_tab [look::dialogbox_row_fillout_line "In the previous X days (optional)" "condition_.Days_" 5 5]
					append this_tab [look::dialogbox_row "On this page" [mf_html::select condition_.InterestPage_ {SIZE=1} [segments::get_interest_page_choices]]]
					append this_tab [look::dialogbox_row "From this mailing" [mf_html::select condition_.InterestMailing_ {SIZE=1} [segments::get_mailings_choices]]]
					
                } else {
                    append this_tab [look::dialogbox_row_fillout_listbox "Member showed" "blank" {} 1 {} {} "<BR>[security::interest_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "This much" "blank" {} 1 {} {} "<BR>[security::interest_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_radio "Of this type of interest" "blank" [translation::listbox_choices {"interest events" e "interest points" p "interest stage" s}] e " "]
					append this_tab [look::dialogbox_row_fillout_date "Before this date (optional)" "blank" 20 20]
					append this_tab [look::dialogbox_row_fillout_line "In the previous X days (optional)" "blank" 5 5]
					append this_tab [look::dialogbox_row_fillout_listbox "On this page" "blank" {} 1 {} {} "<BR>[security::interest_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "From this mailing" "blank" {} 1 {} {} "<BR>[security::interest_feature_disclaimer]"]
                }
            }
        }
	      
	    {
            "Survey" 
            "segments__new_segment__in-8.html"
            {
				
				#puts "---------------------------------------------------------------"
				#puts "refreshing survey page"
				#puts "---------------------------------------------------------------"
				
				## Form dropdown fields:
				#puts "SurveyRespondAction: '[ncgi::value condition_.SurveyRespondAction]'"
				#puts "SurveyWebForm: '[ncgi::value condition_.SurveyWebForm]'"
				#puts "SurveyQuestionAction: '[ncgi::value condition_.SurveyQuestionAction]'"
				#puts "SurveyQuestion: '[ncgi::value condition_.SurveyQuestion]'"
				#puts "SurveyAnswerAction: '[ncgi::value condition_.SurveyAnswerAction]'"
				#puts "SurveyAnswer: '[ncgi::value condition_.SurveyAnswer]'"
				#puts "Multiple: '[ncgi::value condition_.Multiple]'"
				
				## Form field hidden copies:
				#puts "LastSurveyRespondAction: '[ncgi::value condition_.LastSurveyRespondAction]'"
				#puts "LastSurveyWebForm: '[ncgi::value condition_.LastSurveyWebForm]'"
				#puts "LastSurveyQuestionAction: '[ncgi::value condition_.LastSurveyQuestionAction]'"
				#puts "LastSurveyQuestion: '[ncgi::value condition_.LastSurveyQuestion]'"
				#puts "LastMultiple: '[ncgi::value condition_.LastMultiple]'"
				
				set resetquestion 0
				set resetanswer 0
				# check to see what survey is selected or not selected, and populate or blank out the other dropdowns
				# if no survey webform is selected, blank out the questions and answers dropdowns, and initialize the corresponding input fields
				if {([ncgi::value condition_.SurveyWebForm] != [ncgi::value condition_.LastSurveyWebForm])} {
					#puts "Survey form changed"
					if {[ncgi::value condition_.SurveyWebForm] == "any_survey"} {
						# if we no longer have a survey selected, then the options for selecting on specific questions and answers should go away
						if {[ncgi::value condition_.Multiple] == "p"} {
							ncgi::setValue condition_.Multiple "n"
						}
					} else {
						if {[ncgi::value condition_.Multiple] == "p"} {
							# need to reset the chosen answer and question dropdown choices and selected choice
							set resetquestion 1
						}
					}

				# similarly, check the responded/not_responded dropdown, if it changed to not_responded then reset the question and answer dropdowns.
				} elseif {([ncgi::value condition_.SurveyRespondAction] != [ncgi::value condition_.LastSurveyRespondAction])} {
					#puts "respond action changed"
					if {[ncgi::value condition_.SurveyRespondAction] == "did_not_respond_to"} {
						#puts "setting Multiple to 'n'"
						ncgi::setValue condition_.Multiple "n"
					}

				# if the survey has not changed, have a hidden webform containing the ID of the selected question, and see if that has changed.  
				#   If it has, then reset the answer dropdowns.  
				} elseif {[ncgi::value condition_.Multiple] == "p" && [ncgi::value condition_.SurveyQuestion] != [ncgi::value condition_.LastSurveyQuestion]} {
					set resetanswer 1
				}
				
				if {$resetquestion} {
					#puts "resetting question"
					ncgi::setValue condition_.SurveyQuestion "choose_a_question"
					ncgi::setValue condition_.SurveyQuestionAction "answered"
				}
				if {$resetquestion || $resetanswer} {
					#puts "resetting answer"
					ncgi::setValue condition_.SurveyAnswer "any_answer"
					ncgi::setValue condition_.SurveyAnswerAction "selected"
				}
				
				# Initialization:
				if {[ncgi::value condition_.Multiple] == ""} {
					ncgi::setValue condition_.Multiple "n"
				}
				if {[ncgi::value condition_.SurveyWebForm] == ""} {
					ncgi::setValue condition_.SurveyWebForm "any_survey"
				}
				if {[ncgi::value condition_.SurveyRespondAction] == ""} {
					ncgi::setValue condition_.SurveyRespondAction "responded_to"
				}
				if {[ncgi::value condition_.Multiple] == "p"} {
					if {[ncgi::value condition_.SurveyQuestionAction] == ""} {
						ncgi::setValue condition_.SurveyQuestionAction "answered"
					}
					if {[ncgi::value condition_.SurveyQuestion] == ""} {
						ncgi::setValue condition_.SurveyQuestion "choose_a_question"
					}
					if {[ncgi::value condition_.SurveyQuestion] != "choose_a_question"} {
						if {[ncgi::value condition_.SurveyAnswer] == ""} {
							ncgi::setValue condition_.SurveyAnswer "any_answer"
						}
						if {[ncgi::value condition_.SurveyAnswerAction] == ""} {
							ncgi::setValue condition_.SurveyAnswerAction "selected"
						}
					}
				}

				# Once that logic is complete, save a hidden copy of each dropdown field value so we can see next time if they changed.
				ncgi::setValue condition_.LastSurveyRespondAction [ncgi::value condition_.SurveyRespondAction]
				ncgi::setValue condition_.LastSurveyWebForm [ncgi::value condition_.SurveyWebForm]
				ncgi::setValue condition_.LastSurveyQuestionAction [ncgi::value condition_.SurveyQuestionAction]
				ncgi::setValue condition_.LastSurveyQuestion [ncgi::value condition_.SurveyQuestion]
				ncgi::setValue condition_.LastMultiple [ncgi::value condition_.Multiple]
				ncgi::setValue condition_.LastSurveyAnswer [ncgi::value condition_.SurveyAnswer]
				ncgi::setValue condition_.LastSurveyAnswerAction [ncgi::value condition_.SurveyAnswerAction]
				ncgi::setValue condition_.LastSurveyTextComparator [ncgi::value condition_.SurveyTextComparator]
					
				## Form dropdown fields:
				#puts "SurveyRespondAction: '[ncgi::value condition_.SurveyRespondAction]'"
				#puts "SurveyWebForm: '[ncgi::value condition_.SurveyWebForm]'"
				#puts "SurveyQuestionAction: '[ncgi::value condition_.SurveyQuestionAction]'"
				#puts "SurveyQuestion: '[ncgi::value condition_.SurveyQuestion]'"
				#puts "SurveyAnswerAction: '[ncgi::value condition_.SurveyAnswerAction]'"
				#puts "SurveyAnswer: '[ncgi::value condition_.SurveyAnswer]'"
				#puts "Multiple: '[ncgi::value condition_.Multiple]'"

				## Form field hidden copies:
				#puts "LastSurveyRespondAction: '[ncgi::value condition_.LastSurveyRespondAction]'"
				#puts "LastSurveyWebForm: '[ncgi::value condition_.LastSurveyWebForm]'"
				#puts "LastSurveyQuestionAction: '[ncgi::value condition_.LastSurveyQuestionAction]'"
				#puts "LastSurveyQuestion: '[ncgi::value condition_.LastSurveyQuestion]'"
				#puts "LastMultiple: '[ncgi::value condition_.LastMultiple]'"

				set respondactions [translation::listbox_choices {"responded to" "responded_to" "did not respond to" "did_not_respond_to"}]
				set questionactions [translation::listbox_choices {"answered" "answered" "did not answer" "did_not_answer"}]
				set answeractions [translation::listbox_choices {"selected" "selected" "did not select" "did_not_select"}]
				
				# The dropdown lists are populated based on CGI variables 
				set surveyforms [segments::survey_form_choices]
				set questions [segments::survey_question_choices]
				set answers [segments::survey_question_answer_choices]
				
				append this_tab [look::dialogbox_row "Member" "[mf_html::select condition_.SurveyRespondAction {SIZE=1 onchange="document.forms[0].submit()"} $respondactions] [mf_html::select condition_.SurveyWebForm {SIZE=1 onchange="document.forms[0].submit()"} $surveyforms]"  ]
				
				set nchecked ""
				set qchecked ""
				set pchecked ""
				if {[ncgi::value condition_.Multiple] == "n"} {
					set nchecked "CHECKED"
				} elseif {[ncgi::value condition_.Multiple] == "q"} {
					set qchecked "CHECKED"
				} else {
					set pchecked "CHECKED"
				}
				if {[ncgi::value condition_.SurveyRespondAction] == "did_not_respond_to"} {
					append this_tab [text::hidden_fields condition_.Multiple]
				} else {
					if {[ncgi::value condition_.SurveyWebForm] == "any_survey"} {
						append this_tab [look::dialogbox_row "" [subst {<input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="n" $nchecked> no additional filter option<br><input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="q" $qchecked> filter based on number of questions answered<br>}]]
					} else {
						append this_tab [look::dialogbox_row "" [subst {<input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="n" $nchecked> no additional filter option<br><input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="q" $qchecked> filter based on number of questions answered<br><input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="p" $pchecked> filter on how a particular question was answered }]]
					}
				} 

				if {[ncgi::value condition_.Multiple] == "q"} {
					append this_tab [look::dialogbox_section_label "filter based on number of questions answered"]
					set comparators [segments::get_short_numeric_comparators_list]
					append this_tab [look::dialogbox_row_fillout_listbox "Member answered" "condition_.SurveyQuestionsAnsweredComparator_" $comparators 1 ]
					append this_tab [look::dialogbox_row_fillout_line "This many questions" "condition_.SurveyQuestionsAnsweredValue_" 5 5]
				}

				if {[ncgi::value condition_.Multiple] == "p"} {
					append this_tab [look::dialogbox_section_label "filter on a particular question answered"]
					append this_tab [look::dialogbox_row "Member" "[mf_html::select condition_.SurveyQuestionAction {SIZE=1 onchange="document.forms[0].submit()"} $questionactions] [mf_html::select condition_.SurveyQuestion {SIZE=1 onchange="document.forms[0].submit()"} $questions]"  ]
					if {([ncgi::value condition_.SurveyQuestionAction] == "answered") && ([ncgi::value condition_.SurveyQuestion] != "choose_a_question")} {
						append this_tab [look::dialogbox_row "In this way" "[mf_html::select condition_.SurveyAnswerAction {SIZE=1 onchange="document.forms[0].submit()"} $answeractions] [mf_html::select condition_.SurveyAnswer {SIZE=1 onchange="document.forms[0].submit()"} $answers]"  ]
					}
					if {([ncgi::value condition_.SurveyAnswerAction] == "selected") && ([ncgi::value condition_.SurveyAnswer] == "freeform")} {
						set textcomparators [segments::get_survey_text_comparators_list]
						append this_tab [look::dialogbox_row "The text answer" "[mf_html::select condition_.SurveyTextComparator {SIZE=1 onchange="document.forms[0].submit()"} $textcomparators]"  ]
						if {[ncgi::value condition_.SurveyTextComparator] == ""} {
							ncgi::setValue condition_.SurveyTextComparator "is_not_null"
						}
						if {[ncgi::value condition_.SurveyTextComparator] != "is_not_null"} {
							append this_tab [look::dialogbox_row_fillout_line "This text value" {condition_.SurveyTextValue} 80 200]
						}
					}
				}
				append this_tab [look::dialogbox_row "" "<input [translation::inputTagSubmitImage "Refresh"] name=\"refresh\">" ]
				append this_tab [text::hidden_fields {condition_.LastSurveyRespondAction condition_.LastSurveyWebForm condition_.LastSurveyQuestionAction condition_.LastSurveyQuestionAction condition_.LastSurveyQuestion condition_.LastMultiple condition_.LastSurveyAnswer condition_.LastSurveyAnswerAction condition_.LastSurveyTextComparator}]

            }
        }
        
        {
            "Preferences" 
            "segments__new_segment__in-9.html"
            {

				#
				# Adding the preference area
				#
				
					set segment_desc "foo"
					append this_tab [look::dialogbox_row "Segments" [subst {<table border=0 cellspacing=0 cellpadding=0><tr><td>[look::light_table_border $segment_desc]</td><td>[gif::spacer 10 2]</td><td valign="middle" align="right"><input [translation::inputTagSubmitImage "Choose Preferences"] name="choose_preferences"></td></tr></table>}]]
					append this_tab [look::dialogbox_row_fillout_yes_no "Member's Opted-in?" "subsets_.OptStatus_" 1]
					append this_tab [look::dialogbox_row_fillout_yes_no "Use all of the selected preferences?  \n(Select No if you want any of the selected preferences)" "subsets_.AnyOrAll_" 1]
					
        
					
                
            }
        }
        
                {
            "Custom" 
            "segments__new_segment__in-10.html"
            {

				#
				# Adding the Custom area
				#
				
					
					ncgi::setValue "custom.AndOr_" ""
					ncgi::setValue "custom.CriteriaSelection_" ""
					

					append this_tab [look::dialogbox_row "This URL" [mf_html::select custom.CriteriaSelection_ {SIZE=1} [segments::get_custom_criteria_choices]]]
				  append this_tab [look::dialogbox_row "Set Values" [subst {<table border=0 cellspacing=0 cellpadding=0><tr><td>[gif::spacer 10 2]</td><td valign="middle" align="right"><input [translation::inputTagSubmitImage "Set Values"] name="choose_values"></td></tr></table>}]]
					append this_tab [look::dialogbox_row_fillout_paragraph "Query" "subsets_.ClauseWhere_" [ncgi::value QueryFieldHeight 12] 68 {} { sql_where_clause_is_secure_and_not_empty } ]
					
        
				  set send_choices [list [translation::text {And}] "and" [subst {[translation::text "Or"]}] "or"]
    
        append this_tab [look::dialogbox_row "Query Type" [mf_html::radioSetAligned custom.AndOr_ "[gif::spacer 20 1]" $send_choices "and" ]]
                
            }
        }        
    }
    
    
    

    # list the field names, and optionally the 2nd value in the pair is the default value for that
    # field, which is used when creating a new item of this type
    set fields_and_defaults {}
	#set fields_and_defaults {
    #    {condition_.TextFieldname_}
	#	{condition_.TextComparator_}
	#	{condition_.TextValue_}
    #}

    # the name of the table that we'll be reading from and writing to
    #set table_name "condition_"
    set table_name ""

    # the name of the primary key field
    set key_field_name ""

    # the URL to send the user once they've finished with this builder
    set end_url ""

    # the general section in this application this builder is in, so that message pages
    # can be displayed with the right highlighted tab
    set section "content"

    # the names of any read-only fields, that are to be preserved in hidden fields. Usually,
    # these all have default values that the user then can't change, but sometimes is allowed
    # to see.
    set read_only_fields {}

    # call the save/edit/load function, and return the HTML it creates
    append html [look::save_edit_load $table_name $key_field_name $fields_and_defaults $end_url $section $read_only_fields $tab_definitions]

    return $html
}






proc segments::get_survey_forms {} {
	set sql "SELECT Title, WebDocID FROM lyrWebDocs WHERE IsTemplate = 'F' AND WebDocTypeID = 2 AND ( ListID = [security::current_list_id] OR SiteID = [security::current_site_id] OR ( ListID IS NULL AND SiteID IS NULL ) ) order by Title"
	set choices [lyrsql::select_two_columns_as_kv $sql]
	return $choices
}

proc segments::survey_form_choices {} {
	set choices {}
	lappend choices "[translation::text {any survey}]" "any_survey"
	set choices [concat $choices [segments::get_survey_forms]]
	return $choices
}

proc segments::survey_form_name { webdocID } {
	set sql "SELECT Title FROM lyrWebDocs WHERE WebDocID = $webdocID"
	set result ""
	catch {set result [lyrsql::select_value $sql]}
	return $result
}

proc segments::get_survey_questions {} {
	if {[ncgi::value condition_.SurveyWebForm] == "any_survey"} {
		set webformclause ""
	} else {
		set webformclause " and (r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
	}
	set sql "select distinct q.QuestionText, q.QuestionID from lyrSurveyQuestions q, lyrSurveyResponseAnswers ra, lyrSurveyResponse r where q.QuestionID = ra.QuestionID and ra.ResponseID = r.ResponseID $webformclause"
	set choices [lyrsql::select_two_columns_as_kv $sql]
	return $choices
}

proc segments::survey_question_choices {} {
	set choices {}
	lappend choices "[translation::text {(choose a question)}]" "choose_a_question"
	set choices [concat $choices [segments::get_survey_questions]]
	return $choices
}

proc segments::survey_question_name { questionID } {
	set sql "SELECT QuestionText FROM lyrSurveyQuestions WHERE QuestionID = $questionID"
	set result ""
	catch {set result [lyrsql::select_value $sql]}
	return $result
}

proc segments::survey_question_has_freeform { questionID } {
	set sql "SELECT COUNT(*) FROM lyrSurveyResponseAnswers WHERE QuestionID = $questionID AND FreeFormAnswer IS NOT NULL"
	set result ""
	catch {set result [lyrsql::select_value $sql]}
	return $result
}


proc segments::get_survey_answers {} {
	if {[ncgi::value condition_.SurveyWebForm] == "any_survey" || [ncgi::value condition_.SurveyWebForm] == ""} {
		set webformclause ""
	} else {
		set webformclause " and (r.WebDocID = [lmcgi::value_int condition_.SurveyWebForm])"
	}
	if {[ncgi::value condition_.SurveyQuestion] == "choose_a_question" || [ncgi::value condition_.SurveyQuestion] == ""} {
		set questionclause ""
	} else {
		set questionclause " and (ra.QuestionID = [lmcgi::value_int condition_.SurveyQuestion])"
	}
	set sql "select distinct a.AnswerText, a.AnswerID from lyrSurveyAnswers a, lyrSurveyResponseAnswers ra, lyrSurveyResponse r where a.AnswerID = ra.AnswerID and ra.ResponseID = r.ResponseID and a.AnswerText NOT LIKE 'fill-in' $webformclause $questionclause ORDER BY a.AnswerText ASC"
	set choices [lyrsql::select_two_columns_as_kv $sql]
	return $choices
}

proc segments::survey_question_answer_choices {} {
	set choices {}
	set choices [concat $choices [segments::get_survey_answers]]
	if {[segments::survey_question_has_freeform [lmcgi::value_int condition_.SurveyQuestion]] > 0} {
		lappend choices "[translation::text {any answer (fill-in text or multiple-choice)}]" "any_answer"
		lappend choices "[translation::text {any multiple-choice answer}]" "any_multiple_choice"
		lappend choices "[translation::text {a fill-in text answer}]" "freeform"
	} else {
		lappend choices "[translation::text {any answer}]" "any_answer"
	}
	return $choices
}

proc segments::survey_answer_name { answerID } {
	set sql "select AnswerText from lyrSurveyAnswers where AnswerID = $answerID"
	set result ""
	catch {set result [lyrsql::select_value $sql]}
	return $result
}

proc segments::get_survey_text_comparators_list {} {
    set comparators {}
	lappend comparators [translation::text "is not null"] "is_not_null"
    lappend comparators [translation::text "contains"] "contains"      
    lappend comparators [translation::text "does not contain"] "not_contains"
    lappend comparators [translation::text "ends with"] "endswith"
    lappend comparators [translation::text "begins with"] "beginswith"

    return $comparators
}



# Prototype
proc segments::time_offset_unit_options {} {
	set unitoptions {
	 "hours" "hours"
	 "days" "days"
	 "weeks" "weeks"
	 "months" "months"
	 "years" "years" }
	
	 return $unitoptions
}


# Prototype
proc segments::time_offset_number_options {} {
	set numberoptions { 
		{0} {0}
		{1} {1}
		{2} {2}
		{3} {3}
		{4} {4}
		{5} {5}
		{6} {6}
		{7} {7}
		{8} {8}
		{9} {9}
		{10} {10}
		{11} {11}
		{12} {12}
		{13} {13}
		{14} {14}
		{15} {15}
		{16} {16}
		{17} {17}
		{18} {18}
		{19} {19}
		{20} {20}
		{21} {21}
		{22} {22}
		{23} {23}
		{24} {24}
		{25} {25}
		{26} {26}
		{27} {27}
		{28} {28}
		{29} {29}
		{30} {30}
		{31} {31}
		{32} {32}
		{33} {33}
		{34} {34}
		{35} {35}
		{36} {36}
		{37} {37}
		{38} {38}
		{39} {39}
		{40} {40}
		{41} {41}
		{42} {42}
		{43} {43}
		{44} {44}
		{45} {45}
		{46} {46}
		{47} {47}
		{48} {48}
		{49} {49}
		{50} {50}
		{51} {51}
		{52} {52}
		{53} {53}
		{54} {54}
		{55} {55}
		{56} {56}
		{57} {57}
		{58} {58}
		{59} {59}
		{60} {60} }
	
	return $numberoptions
}


# Prototype
proc segments::insert_trigger {} {

    if {[string length [lmcgi::button_pressed_list {"insert-trigger-new-do"  "cancel-trigger-new-do"}]] > 0} {
        # finished with insert-field wizard, so go back to where we came from
        #lmcgi::Doc_Post "/segments/new.tml"
		lmcgi::Doc_Post "/segments/new_triggered.tml?[lmcgi::clist_url]"
    }

	#puts "button pressed: '[lmcgi::which_button_pressed]'"
	#puts "tab selected: '[ncgi::value current_tab]'"
	if {([ncgi::value current_tab] == "Survey") && ([lmcgi::which_button_pressed] == "" || [lmcgi::which_button_pressed] == "refresh")} {
		#puts "was on survey page"
		ncgi::setValue "tab_survey" 1
	}

    set tab_definitions {
        {
            "Date" 
            "segments__new_triggered_s-1.html"
            {
                set dbfields [segments::get_date_fields_list]
		set timefromeventvalue [segments::time_offset_number_options]
		set timefromeventpastfuture {"in the past" "past" "in the future" "future"}  
		set timefromeventunits [segments::time_offset_unit_options]
				
		set dateanniversary [translation::listbox_choices {"exact date and time" "exact_date_and_time" "anniversary" "anniversary"}]
                set each 0
		ncgi::setValue "condition_.ANDFieldname${each}_" ""
		if {[security::pro_content_allowed]} {
		    append this_tab [look::dialogbox_row_fillout_listbox "Date type" "condition_.DateAnniversary_" $dateanniversary 1 ]
                    append this_tab [look::dialogbox_row "Date field" [mf_html::selectPlain condition_.DateFieldname_ {SIZE=1} [concat [list [translation::text "select a date field"]] [lsort $dbfields]]]]
                    #append this_tab [look::dialogbox_row "occurred" "[mf_html::select condition_.DateTimeFromEventValue_ {SIZE=1} $timefromeventvalue] [mf_html::select condition_.DateTimeFromEventUnits_ {SIZE=1} $timefromeventunits] [mf_html::select condition_.DateTimeFromEventPastFuture_ {SIZE=1} $timefromeventpastfuture]"  ]
		} else {
		    append this_tab [look::dialogbox_row_fillout_listbox "Date type" "blank" $dbfields 1 {} {} "<BR>[security::pro_content_disclaimer]"]
		    append this_tab [look::dialogbox_row_fillout_listbox "Date field" "blank" $dbfields 1 {} {} "<BR>[security::pro_content_disclaimer]"]
		    #append this_tab [look::dialogbox_row "occurred" "[mf_html::select blank {SIZE=1} $timefromeventvalue] [mf_html::select blank {SIZE=1} $timefromeventunits] [mf_html::select blank {SIZE=1} $timefromeventpastfuture]"  ]
		}
	    	
	    }
        }
        {
            "Action" 
            "segments__new_triggered_s-2.html"
            {
				set timefromeventvalue [segments::time_offset_number_options]
				set timefromeventpastfuture {"in the past" "past" "in the future" "future"}  
				set timefromeventunits [segments::time_offset_unit_options]
                if {[security::purchase_tracking_allowed]} {
					set actions [translation::listbox_choices {"opened" "opened" "clicked on any url in" "clicked_on_any_url_in" "visited any page" "visited_any_page" "purchased after" "purchased_after"}]
				} else {
					set actions [translation::listbox_choices {"opened" "opened" "clicked on any url in" "clicked_on_any_url_in" "visited any page" "visited_any_page"}]
				}
                #set actions {"opened" "opened" "did not open" "did_not_open" "clicked on any url in" "clicked_on_any_url_in" "did not click on any url in" "did_not_click_on_any_url_in" "visited from" "visited_from" "did not visit from" "did_not_visit_from" "purchased from" "purchased_from" "did not purchase from" "did_not_purchase_from"}
                if {[security::pro_content_allowed]} {
                    append this_tab [look::dialogbox_row_fillout_listbox "Action" "condition_.Action_" $actions 1 ]
					append this_tab [look::dialogbox_row "Mailing" [mf_html::select condition_.ActionMailing_ {SIZE=1} [segments::get_mailings_choices]]]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select condition_.ActionTimeFromEventValue_ {SIZE=1} $timefromeventvalue] [mf_html::select condition_.ActionTimeFromEventUnits_ {SIZE=1} $timefromeventunits] [mf_html::select condition_.ActionTimeFromEventPastFuture_ {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row_fillout_radio "Trigger will send to this member" "condition_.ActionAggregationType_" [translation::listbox_choices {"every time" e "the first time" f}] e " "]
                } else {
                    append this_tab [look::dialogbox_row_fillout_listbox "Action" "blank" "" 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "Mailing" "blank" "" 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select blank {SIZE=1} $timefromeventvalue] [mf_html::select blank {SIZE=1} $timefromeventunits] [mf_html::select blank {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row_fillout_radio "Trigger will send to this member" "blank" [translation::listbox_choices {"every time" e "the first time" f}] e " "]
                }

            }
        }
        {
            "Clickthrough" 
            "segments__new_triggered_s-3.html"
            {
				set timefromeventvalue [segments::time_offset_number_options]
				set timefromeventpastfuture {"in the past" "past" "in the future" "future"}  
				set timefromeventunits [segments::time_offset_unit_options]
                set actions [translation::listbox_choices { "clicked on" "clicked_on"}]
                #set actions {"clicked on" "clicked_on" "did not click on" "did_not_click_on"}
                if {[security::pro_content_allowed]} {
                    append this_tab [look::dialogbox_row_fillout_listbox "Member" "condition_.ClickthroughAction_" $actions 1 ]
					append this_tab [look::dialogbox_row "This URL" [mf_html::select condition_.ClickthroughUrl_ {SIZE=1} [segments::get_url_choices]]]
					append this_tab [look::dialogbox_row "In this mailing" [mf_html::select condition_.ClickthroughMailing_ {SIZE=1} [segments::get_mailings_choices]]]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select condition_.ClickthroughTimeFromEventValue_ {SIZE=1} $timefromeventvalue] [mf_html::select condition_.ClickthroughTimeFromEventUnits_ {SIZE=1} $timefromeventunits] [mf_html::select condition_.ClickthroughTimeFromEventPastFuture_ {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row_fillout_radio "Trigger will send to this member" "condition_.ClickthroughAggregationType_" [translation::listbox_choices {"every time" e "the first time" f}] e " "]
                } else {
                    append this_tab [look::dialogbox_row_fillout_listbox "Member" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "This URL" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "In this mailing" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select blank {SIZE=1} $timefromeventvalue] [mf_html::select blank {SIZE=1} $timefromeventunits] [mf_html::select blank {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row_fillout_radio "Trigger will send to this member" "blank" [translation::listbox_choices {"every time" e "the first time" f}] e " "]
                }
            }
        }
        {
            "Clickstream" 
            "segments__new_triggered_s-4.html"
            {
				set timefromeventvalue [segments::time_offset_number_options]
				set timefromeventpastfuture {"in the past" "past" "in the future" "future"}  
				set timefromeventunits [segments::time_offset_unit_options]
				#set actions {"viewed" "viewed" "did not view" "did_not_view" }
				set actions [translation::listbox_choices {"viewed" "viewed"}]
				if {[security::pro_content_allowed]} {
					append this_tab [look::dialogbox_row_fillout_listbox "Member" "condition_.ClickstreamAction_" $actions 1 ]
					append this_tab [look::dialogbox_row "This page" [mf_html::select condition_.ClickstreamPage_ {SIZE=1} [segments::get_clickstream_page_choices]]]
					append this_tab [look::dialogbox_row "From this mailing" [mf_html::select condition_.ClickstreamMailing_ {SIZE=1} [segments::get_mailings_choices]]]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select condition_.ClickstreamTimeFromEventValue_ {SIZE=1} $timefromeventvalue] [mf_html::select condition_.ClickstreamTimeFromEventUnits_ {SIZE=1} $timefromeventunits] [mf_html::select condition_.ClickstreamTimeFromEventPastFuture_ {SIZE=1} $timefromeventpastfuture]" ]
					append this_tab [look::dialogbox_row_fillout_radio "Trigger will send to this member" "condition_.ClickstreamAggregationType_" [translation::listbox_choices {"every time" e "the first time" f}] e " "]
				} else {
					append this_tab [look::dialogbox_row_fillout_listbox "Member" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "This page" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "From this mailing" "blank" {} 1 {} {} "<BR>[security::pro_content_disclaimer]"]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select blank {SIZE=1} $timefromeventvalue] [mf_html::select blank {SIZE=1} $timefromeventunits] [mf_html::select blank {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row_fillout_radio "Trigger will send to this member" "blank" [translation::listbox_choices {"every time" e "the first time" f}] e " "]
				}
            }
        }
		{
            "Purchase" 
            "segments__new_triggered_s-5.html"
            {
				set timefromeventvalue [segments::time_offset_number_options]
				set timefromeventpastfuture {"in the past" "past" "in the future" "future"}  
				set timefromeventunits [segments::time_offset_unit_options]
                set comparators [segments::get_short_numeric_comparators_list]
				
				ncgi::setValue condition_.PurchaseAmountComparator_ {>}
				ncgi::setValue condition_.PurchaseAmount_ 0
				set comparators [segments::get_short_numeric_comparators_list]
				if {[security::purchase_tracking_allowed]} {
					append this_tab [look::dialogbox_row_fillout_listbox "Member bought" "condition_.PurchaseAmountComparator_" $comparators 1 ]
					append this_tab [look::dialogbox_row_fillout_line "This amount" "condition_.PurchaseAmount_" 10 15 ]
					append this_tab [look::dialogbox_row_fillout_radio "" "condition_.PurchaseType_" [translation::listbox_choices {"price" p "quantity" q}] p " "]
					append this_tab [look::dialogbox_row_fillout_radio "" "condition_.PurchaseAggregationType_" [translation::listbox_choices {"since the last runtime" a "since forever" c "since forever, reached for the first time" f}] f " "]
					append this_tab [look::dialogbox_row_fillout_line "of this product code (optional)" "condition_.PurchaseSKU_" 20 25]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select condition_.PurchaseTimeFromEventValue_ {SIZE=1} $timefromeventvalue] [mf_html::select condition_.PurchaseTimeFromEventUnits_ {SIZE=1} $timefromeventunits] [mf_html::select condition_.PurchaseTimeFromEventPastFuture_ {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row "On this page" [mf_html::select condition_.PurchasePage_ {SIZE=1} [segments::get_purchase_page_choices]]]
					append this_tab [look::dialogbox_row "From this mailing" [mf_html::select condition_.PurchaseMailing_ {SIZE=1} [segments::get_mailings_choices]]]
				} else {
					append this_tab [look::dialogbox_row_fillout_listbox "Member bought" "blank" {} 1 {} {} "<BR>[security::purchase_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_line "This amount" "blank" 10 15 ]
					append this_tab [look::dialogbox_row_fillout_radio "" "blank" [translation::listbox_choices {"price" p "quantity" q}] p " "]
					append this_tab [look::dialogbox_row_fillout_radio "" "condition_.PurchaseAggregationType_" [translation::listbox_choices {"since the last runtime" a "since forever" c "since forever, reached for the first time" f}] f " "]
					append this_tab [look::dialogbox_row_fillout_line "Of this product code (optional)" "blank" 5 10]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select blank {SIZE=1} $timefromeventvalue] [mf_html::select blank {SIZE=1} $timefromeventunits] [mf_html::select blank {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row_fillout_listbox "On this page" "blank" {} 1 {} {} "<BR>[security::purchase_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "From this mailing" "blank" {} 1 {} {} "<BR>[security::purchase_feature_disclaimer]"]
				}
            }
        }
		{
            "Interest" 
            "segments__new_triggered_s-6.html"
            {
				set timefromeventvalue [segments::time_offset_number_options]
				set timefromeventpastfuture [translation::listbox_choices {"in the past" "past" "in the future" "future"}] 
				set timefromeventunits [segments::time_offset_unit_options]
				ncgi::setValue condition_.InterestAmountComparator_ {>}
				ncgi::setValue condition_.InterestAmount_ 0
				set comparators [segments::get_short_numeric_comparators_list]
				if {[security::interest_tracking_allowed]} {
					append this_tab [look::dialogbox_row_fillout_listbox "Member showed" "condition_.InterestAmountComparator_" $comparators 1 ]
					append this_tab [look::dialogbox_row_fillout_line "This much" "condition_.InterestAmount_" 10 15 ]
					append this_tab [look::dialogbox_row_fillout_radio "Of this type of interest" "condition_.InterestType_" [translation::listbox_choices {"interest points" p "interest stage" s "interest events" e}] p " "]
					append this_tab [look::dialogbox_row_fillout_radio "Which occurred" "condition_.InterestAggregationType_" [translation::listbox_choices {"since the last runtime" a "since forever" c "since forever, reached for the first time" f}] f " "]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select condition_.InterestTimeFromEventValue_ {SIZE=1} $timefromeventvalue] [mf_html::select condition_.InterestTimeFromEventUnits_ {SIZE=1} $timefromeventunits] [mf_html::select condition_.InterestTimeFromEventPastFuture_ {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row "On this page" [mf_html::select condition_.InterestPage_ {SIZE=1} [segments::get_interest_page_choices]]]
					append this_tab [look::dialogbox_row "From this mailing" [mf_html::select condition_.InterestMailing_ {SIZE=1} [segments::get_mailings_choices]]]

				} else {
					append this_tab [look::dialogbox_row_fillout_listbox "Member showed" "blank" {} 1 {} {} "<BR>[security::interest_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "This much" "blank" {} 1 {} {} "<BR>[security::interest_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_radio "Of this type of interest" "blank" [translation::listbox_choices {"interest points" p "interest stage" s "interest events" e}] p " "]
					append this_tab [look::dialogbox_row_fillout_radio "Which occurred" "blank" [translation::listbox_choices {"since the last runtime" a "since forever" c "since forever, reached for the first time" f}] f " "]
					#append this_tab [look::dialogbox_row "at this time" "[mf_html::select blank {SIZE=1} $timefromeventvalue] [mf_html::select blank {SIZE=1} $timefromeventunits] [mf_html::select blank {SIZE=1} $timefromeventpastfuture]"  ]
					append this_tab [look::dialogbox_row_fillout_listbox "On this page" "blank" {} 1 {} {} "<BR>[security::interest_feature_disclaimer]"]
					append this_tab [look::dialogbox_row_fillout_listbox "From this mailing" "blank" {} 1 {} {} "<BR>[security::interest_feature_disclaimer]"]
				}
            }
        }
		{
            "Survey" 
            "segments__new_triggered_s-7.html"
            {
				
				#puts "---------------------------------------------------------------"
				#puts "refreshing survey page"
				#puts "---------------------------------------------------------------"
				
				## Form dropdown fields:
				#puts "SurveyRespondAction: '[ncgi::value condition_.SurveyRespondAction]'"
				#puts "SurveyWebForm: '[ncgi::value condition_.SurveyWebForm]'"
				#puts "SurveyQuestionAction: '[ncgi::value condition_.SurveyQuestionAction]'"
				#puts "SurveyQuestion: '[ncgi::value condition_.SurveyQuestion]'"
				#puts "SurveyAnswerAction: '[ncgi::value condition_.SurveyAnswerAction]'"
				#puts "SurveyAnswer: '[ncgi::value condition_.SurveyAnswer]'"
				#puts "Multiple: '[ncgi::value condition_.Multiple]'"
				
				## Form field hidden copies:
				#puts "LastSurveyRespondAction: '[ncgi::value condition_.LastSurveyRespondAction]'"
				#puts "LastSurveyWebForm: '[ncgi::value condition_.LastSurveyWebForm]'"
				#puts "LastSurveyQuestionAction: '[ncgi::value condition_.LastSurveyQuestionAction]'"
				#puts "LastSurveyQuestion: '[ncgi::value condition_.LastSurveyQuestion]'"
				#puts "LastMultiple: '[ncgi::value condition_.LastMultiple]'"
				
				set resetquestion 0
				set resetanswer 0
				# check to see what survey is selected or not selected, and populate or blank out the other dropdowns
				# if no survey webform is selected, blank out the questions and answers dropdowns, and initialize the corresponding input fields
				if {([ncgi::value condition_.SurveyWebForm] != [ncgi::value condition_.LastSurveyWebForm])} {
					#puts "Survey form changed"
					if {[ncgi::value condition_.SurveyWebForm] == "any_survey"} {
						# if we no longer have a survey selected, then the options for selecting on specific questions and answers should go away
						if {[ncgi::value condition_.Multiple] == "p"} {
							ncgi::setValue condition_.Multiple "n"
						}
					} else {
						if {[ncgi::value condition_.Multiple] == "p"} {
							# need to reset the chosen answer and question dropdown choices and selected choice
							set resetquestion 1
						}
					}

				# similarly, check the responded/not_responded dropdown, if it changed to not_responded then reset the question and answer dropdowns.
				} elseif {([ncgi::value condition_.SurveyRespondAction] != [ncgi::value condition_.LastSurveyRespondAction])} {
					#puts "respond action changed"
					if {[ncgi::value condition_.SurveyRespondAction] == "did_not_respond_to"} {
						#puts "setting Multiple to 'n'"
						ncgi::setValue condition_.Multiple "n"
					}

				# if the survey has not changed, have a hidden webform containing the ID of the selected question, and see if that has changed.  
				#   If it has, then reset the answer dropdowns.  
				} elseif {[ncgi::value condition_.Multiple] == "p" && [ncgi::value condition_.SurveyQuestion] != [ncgi::value condition_.LastSurveyQuestion]} {
					set resetanswer 1
				}
				
				if {$resetquestion} {
					#puts "resetting question"
					ncgi::setValue condition_.SurveyQuestion "choose_a_question"
					ncgi::setValue condition_.SurveyQuestionAction "answered"
				}
				if {$resetquestion || $resetanswer} {
					#puts "resetting answer"
					ncgi::setValue condition_.SurveyAnswer "any_answer"
					ncgi::setValue condition_.SurveyAnswerAction "selected"
				}
				
				# Initialization:
				if {[ncgi::value condition_.Multiple] == ""} {
					ncgi::setValue condition_.Multiple "n"
				}
				if {[ncgi::value condition_.SurveyWebForm] == ""} {
					ncgi::setValue condition_.SurveyWebForm "any_survey"
				}
				if {[ncgi::value condition_.SurveyRespondAction] == ""} {
					ncgi::setValue condition_.SurveyRespondAction "responded_to"
				}
				if {[ncgi::value condition_.Multiple] == "p"} {
					if {[ncgi::value condition_.SurveyQuestionAction] == ""} {
						ncgi::setValue condition_.SurveyQuestionAction "answered"
					}
					if {[ncgi::value condition_.SurveyQuestion] == ""} {
						ncgi::setValue condition_.SurveyQuestion "choose_a_question"
					}
					if {[ncgi::value condition_.SurveyQuestion] != "choose_a_question"} {
						if {[ncgi::value condition_.SurveyAnswer] == ""} {
							ncgi::setValue condition_.SurveyAnswer "any_answer"
						}
						if {[ncgi::value condition_.SurveyAnswerAction] == ""} {
							ncgi::setValue condition_.SurveyAnswerAction "selected"
						}
					}
				}

				# Once that logic is complete, save a hidden copy of each dropdown field value so we can see next time if they changed.
				ncgi::setValue condition_.LastSurveyRespondAction [ncgi::value condition_.SurveyRespondAction]
				ncgi::setValue condition_.LastSurveyWebForm [ncgi::value condition_.SurveyWebForm]
				ncgi::setValue condition_.LastSurveyQuestionAction [ncgi::value condition_.SurveyQuestionAction]
				ncgi::setValue condition_.LastSurveyQuestion [ncgi::value condition_.SurveyQuestion]
				ncgi::setValue condition_.LastMultiple [ncgi::value condition_.Multiple]
				ncgi::setValue condition_.LastSurveyAnswer [ncgi::value condition_.SurveyAnswer]
				ncgi::setValue condition_.LastSurveyAnswerAction [ncgi::value condition_.SurveyAnswerAction]
				ncgi::setValue condition_.LastSurveyTextComparator [ncgi::value condition_.SurveyTextComparator]
					
				## Form dropdown fields:
				#puts "SurveyRespondAction: '[ncgi::value condition_.SurveyRespondAction]'"
				#puts "SurveyWebForm: '[ncgi::value condition_.SurveyWebForm]'"
				#puts "SurveyQuestionAction: '[ncgi::value condition_.SurveyQuestionAction]'"
				#puts "SurveyQuestion: '[ncgi::value condition_.SurveyQuestion]'"
				#puts "SurveyAnswerAction: '[ncgi::value condition_.SurveyAnswerAction]'"
				#puts "SurveyAnswer: '[ncgi::value condition_.SurveyAnswer]'"
				#puts "Multiple: '[ncgi::value condition_.Multiple]'"

				## Form field hidden copies:
				#puts "LastSurveyRespondAction: '[ncgi::value condition_.LastSurveyRespondAction]'"
				#puts "LastSurveyWebForm: '[ncgi::value condition_.LastSurveyWebForm]'"
				#puts "LastSurveyQuestionAction: '[ncgi::value condition_.LastSurveyQuestionAction]'"
				#puts "LastSurveyQuestion: '[ncgi::value condition_.LastSurveyQuestion]'"
				#puts "LastMultiple: '[ncgi::value condition_.LastMultiple]'"

				set respondactions [translation::listbox_choices {"responded to" "responded_to" "did not respond to" "did_not_respond_to"}]
				set questionactions [translation::listbox_choices {"answered" "answered" "did not answer" "did_not_answer"}]
				set answeractions [translation::listbox_choices {"selected" "selected" "did not select" "did_not_select"}]
				
				# The dropdown lists are populated based on CGI variables 
				set surveyforms [segments::survey_form_choices]
				set questions [segments::survey_question_choices]
				set answers [segments::survey_question_answer_choices]
				
				append this_tab [look::dialogbox_row "Member" "[mf_html::select condition_.SurveyRespondAction {SIZE=1 onchange="document.forms[0].submit()"} $respondactions] [mf_html::select condition_.SurveyWebForm {SIZE=1 onchange="document.forms[0].submit()"} $surveyforms]"  ]
				
				set nchecked ""
				set qchecked ""
				set pchecked ""
				if {[ncgi::value condition_.Multiple] == "n"} {
					set nchecked "CHECKED"
				} elseif {[ncgi::value condition_.Multiple] == "q"} {
					set qchecked "CHECKED"
				} else {
					set pchecked "CHECKED"
				}
				if {[ncgi::value condition_.SurveyRespondAction] == "did_not_respond_to"} {
					append this_tab [text::hidden_fields condition_.Multiple]
				} else {
					if {[ncgi::value condition_.SurveyWebForm] == "any_survey"} {
						append this_tab [look::dialogbox_row "" [subst {<input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="n" $nchecked> no additional filter option<br><input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="q" $qchecked> filter based on number of questions answered<br>}]]
					} else {
						append this_tab [look::dialogbox_row "" [subst {<input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="n" $nchecked> no additional filter option<br><input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="q" $qchecked> filter based on number of questions answered<br><input type="radio" onclick="document.forms\[0\].submit()" name="condition_.Multiple" value="p" $pchecked> filter on how a particular question was answered }]]
					}
				} 

				if {[ncgi::value condition_.Multiple] == "q"} {
					append this_tab [look::dialogbox_section_label "filter based on number of questions answered"]
					set comparators [segments::get_short_numeric_comparators_list]
					append this_tab [look::dialogbox_row_fillout_listbox "Member answered" "condition_.SurveyQuestionsAnsweredComparator_" $comparators 1 ]
					append this_tab [look::dialogbox_row_fillout_line "This many questions" "condition_.SurveyQuestionsAnsweredValue_" 5 5]
				}

				if {[ncgi::value condition_.Multiple] == "p"} {
					append this_tab [look::dialogbox_section_label "filter on a particular question answered"]
					append this_tab [look::dialogbox_row "Member" "[mf_html::select condition_.SurveyQuestionAction {SIZE=1 onchange="document.forms[0].submit()"} $questionactions] [mf_html::select condition_.SurveyQuestion {SIZE=1 onchange="document.forms[0].submit()"} $questions]"  ]
					if {([ncgi::value condition_.SurveyQuestionAction] == "answered") && ([ncgi::value condition_.SurveyQuestion] != "choose_a_question")} {
						append this_tab [look::dialogbox_row "In this way" "[mf_html::select condition_.SurveyAnswerAction {SIZE=1 onchange="document.forms[0].submit()"} $answeractions] [mf_html::select condition_.SurveyAnswer {SIZE=1 onchange="document.forms[0].submit()"} $answers]"  ]
					}
					if {([ncgi::value condition_.SurveyAnswerAction] == "selected") && ([ncgi::value condition_.SurveyAnswer] == "freeform")} {
						set textcomparators [segments::get_survey_text_comparators_list]
						append this_tab [look::dialogbox_row "The text answer" "[mf_html::select condition_.SurveyTextComparator {SIZE=1 onchange="document.forms[0].submit()"} $textcomparators]"  ]
						if {[ncgi::value condition_.SurveyTextComparator] == ""} {
							ncgi::setValue condition_.SurveyTextComparator "is_not_null"
						}
						if {[ncgi::value condition_.SurveyTextComparator] != "is_not_null"} {
							append this_tab [look::dialogbox_row_fillout_line "This text value" {condition_.SurveyTextValue} 80 200]
						}
					}
				}

				append this_tab [look::dialogbox_row "" "<input [translation::inputTagSubmitImage "Refresh"] name=\"refresh\">" ]
				append this_tab [text::hidden_fields {condition_.LastSurveyRespondAction condition_.LastSurveyWebForm condition_.LastSurveyQuestionAction condition_.LastSurveyQuestionAction condition_.LastSurveyQuestion condition_.LastMultiple condition_.LastSurveyAnswer condition_.LastSurveyAnswerAction condition_.LastSurveyTextComparator}]

            }
        }
	}

    set fields_and_defaults {
    }

    # the name of the table that we'll be reading from and writing to
    set table_name ""

    # the name of the primary key field
    set key_field_name ""

    # the URL to send the user once they've finished with this builder
    set end_url ""

    # the general section in this application this builder is in, so that message pages
    # can be displayed with the right highlighted tab
    set section "content"

    # the names of any read-only fields, that are to be preserved in hidden fields. Usually,
    # these all have default values that the user then can't change, but sometimes is allowed
    # to see.
    set read_only_fields {}

    # call the save/edit/load function, and return the HTML it creates
    append html [look::save_edit_load $table_name $key_field_name $fields_and_defaults $end_url $section $read_only_fields $tab_definitions]

    return $html
}



proc segments::strip_SQL_quotes { clause } {
	set clause [string trim $clause]
	set len [expr [string length $clause] - 1]
	if {[string range $clause 0 0] == "'" && [string range $clause $len $len] == "'"} {
		set clause [string range $clause 1 [expr ($len - 1)]]
	}
}

proc segments::get_table_stuff { textfieldname } {

			set table_name [misc::get_table_name $textfieldname]

			if {[lindex [split $table_name] 1] ne ""} {
				set table_alias [lindex [split $table_name] 1]
			} else {
				set table_alias $table_name
			}

			set txtfieldname [lindex [split $textfieldname .] [expr [llength [split $textfieldname .]]-1]]

			return [list $txtfieldname $table_alias $table_name]
}

proc segments::test_segment { } {

	# puts "CurrentRuntime_0: '[ncgi::value CurrentRuntime_]'"
	# puts "PreviousRuntime_0: '[ncgi::value PreviousRuntime_]'"

	if {[security::triggered_mailings_allowed] && (([ncgi::value display_no_prompt] == "") && [dbinfo::is_triggered_segment [lmcgi::value_int id]])} {
		# This is a triggered segment and we should prompt for what hardcoded dates to use for the test
		# We will just save the new hardcoded dates in the segment.

		# get the data for this table
		set sql "select subsets_.ClauseWhere_ from subsets_ where subsets_.List_=[lyrsql::quote [security::current_list]] and subsets_.SubsetID_= [lmcgi::value_int id]"
		lyrsql::select $sql results  

		# assuming one list only, and one row returned only
		#puts "results(clausewhere_): '$results(clausewhere_)'"

		set clausewhere [lindex $results(clausewhere_) 0]

                if { [dbinfo::is_mssql] } {
                    regsub -all {\/\*currentdatetime\*\/.*?\/\*endcurrentdatetime\*\/} $clausewhere "/*currentdatetime*/CAST([lyrsql::quote [date::clockToSQLDateTime]] AS datetime)/*endcurrentdatetime*/" clausewhere
                } else {
                    regsub -all {\/\*currentdatetime\*\/.*?\/\*endcurrentdatetime\*\/} $clausewhere "/*currentdatetime*/[lyrsql::quote [date::clockToSQLDateTime]]/*endcurrentdatetime*/" clausewhere
                }

		# set initial currentRuntime_ and PreviousRunTime_ to blank
		ncgi::setValue CurrentRuntime_ ""
		ncgi::setValue PreviousRuntime_ ""
                set html [look::bread_crumbs "" 1 [lmcgi::page_url] "" "" "" "" ]

		append html "<form action=\"test\" method=\"POST\">"
		ncgi::setValue display_no_prompt 1
		append html [text::hidden_fields {id display_no_prompt} ]


		append html "
			[look::dialogbox_start_no_title]
		
			<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" width=\"[look::dialogbox_content_cell_width]\">
			[look::dialogbox_row "" [translation::text "Please enter a date range (with or without time) to test the trigger.  The format is YYYY-MM-DD HH:MM:SS.  Members who meet the trigger segment criteria within this date range will be listed."]]
			</table>
			
			<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" width=\"[look::dialogbox_content_cell_width]\">
                        [look::dialogbox_row_fillout_datetime "Start Date" "PreviousRuntime_" 20 20  {is_sql_date} "&nbsp;<font [htmltag::font_face] size=\"1\"><i>yyyy-mm-dd hh:mm:ss</i></font>" "[date::clockToSQLDate]"]
                        [look::dialogbox_row_fillout_datetime "End Date" "CurrentRuntime_" 20 20 {is_sql_date} "&nbsp;<font [htmltag::font_face] size=\"1\"><i>yyyy-mm-dd hh:mm:ss</i></font>" "[date::clockToSQLDate]"]
			</table>
			[look::dialogbox_end ]
			[look::dialogbox_buttons "<input [translation::inputTagSubmitImage Ok] name=\"ok\">" ]
			</form>"
		
		
		
	} else {
		set testArgs ""
		set testClauseWhere ""
		# save the new current_runtime and last_runtime in the where clause of the segment
		if {[security::triggered_mailings_allowed] && ([dbinfo::is_triggered_segment [lmcgi::value_int id]])} {
			if {([ncgi::value CurrentRuntime_] != "") && ([ncgi::value PreviousRuntime_] != "")} {

				# PreviousRuntime_ is used for trigger Start Date
				set message [validate::is_sql_date "Start Date" [ncgi::value PreviousRuntime_]]
				if { $message != "" } {
					look::redirect_to_message_page "" $message "segments" ""
				}				

				# CurrentRuntime_ is used for trigger End Date
				set message [validate::is_sql_date "End Date" [ncgi::value CurrentRuntime_]]
				if { $message != "" } {
					look::redirect_to_message_page "" $message "segments" ""
				}				

				# get the data for this table
				set sql "select subsets_.ClauseWhere_ from subsets_ where subsets_.List_=[lyrsql::quote [security::current_list]] and subsets_.SubsetID_= [lmcgi::value_int id]"
				lyrsql::select $sql results  


				# assuming one list only, and one row returned only
				#puts "results(clausewhere_): '$results(clausewhere_)'"

				set clausewhere [lindex $results(clausewhere_) 0]

                                if { [dbinfo::is_mssql] } {
                                    regsub -all {\/\*currentdatetime\*\/.*?\/\*endcurrentdatetime\*\/} $clausewhere "/*currentdatetime*/CAST([lyrsql::quote [date::clockToSQLDateTime]] AS datetime)/*endcurrentdatetime*/" clausewhere
                                } else {
                                    regsub -all {\/\*currentdatetime\*\/.*?\/\*endcurrentdatetime\*\/} $clausewhere "/*currentdatetime*/[lyrsql::quote [date::clockToSQLDateTime]]/*endcurrentdatetime*/" clausewhere
                                }
                	        set crt [ncgi::value CurrentRuntime_]
                	        set prt [ncgi::value PreviousRuntime_]
                	        if {[clock scan $prt]>=[clock scan $crt]} {
                		    look::redirect_to_message_page "" [translation::text "Start date must be before end date"] "segments" ""
                	        }

				if {$crt != ""} {
					set clausewhere [dbinfo::queryparser_set_this_runtime $clausewhere [lyrsql::quote $crt] ]
					append testArgs "&CurrentRuntime_=[ncgi::value CurrentRuntime_]"
				}
				if {$prt != ""} {
					set clausewhere [dbinfo::queryparser_set_last_runtime $clausewhere [lyrsql::quote $prt] ]
					append testArgs "&PreviousRuntime_=[ncgi::value PreviousRuntime_]"
				}
				
				set testClauseWhere $clausewhere
			} else {
				# puts "CurrentRuntime_1: '[ncgi::value CurrentRuntime_]'"
				# puts "PreviousRuntime_1: '[ncgi::value PreviousRuntime_]'"

				# PreviousRunTime_ is used for trigger Start Date
				if {[ncgi::value PreviousRuntime_] == ""} {
					look::redirect_to_message_page "" [translation::text "Error: Start Date is required. Please enter a trigger Start Date."] "segments" ""
				}

				# CurrentRunTime_ is used for trigger End Date
				if {[ncgi::value CurrentRuntime_] == ""} {
					look::redirect_to_message_page "" [translation::text "Error: End Date is required. Please enter a trigger End Date."] "segments" ""
				}
			}
		} else {
			# puts "ERROR segments.tml:segments::test_segment"
		}

		# display the results of the test

		set index_function_url [security::vtable_function_url segments::page_test "segments" segmenttesttable]
		if {$testArgs!=""} {
			append index_function_url $testArgs
		}
		append index_function_url "&sq=[ncgi::value sq]&viewtable_type=[ncgi::value viewtable_type]"
		set html [look::bread_crumbs "" 1 [lmcgi::page_url] "" "segmenttesttable" "$index_function_url" "viewsegments.html?search.html?~noresize~" 0 1]
		append html [scripts::updatebuttons]
		append html [look::dialogbox_below_titlebox_begin]
		set statement "SELECT SubsetID_, Name_, Desc_, ClauseSelect_, ClauseFrom_, ClauseWhere_, ClauseAfterSelect_, ClauseOrderBy_, AddWhereList_, AddWhereMemberType_, AddWhereSubType_, NumTestRecords_ FROM subsets_ WHERE SubsetID_=[lmcgi::value_int id]"

		lyrsql::select_row $statement kv_array
		set crt [ncgi::value CurrentRuntime_]
		set prt [ncgi::value PreviousRuntime_]
		set clausewhere $kv_array(clausewhere_)
		if {$crt != ""} {
			set clausewhere [dbinfo::queryparser_set_this_runtime $clausewhere [lyrsql::quote $crt] ]
		}
		if {$prt != ""} {
			set clausewhere [dbinfo::queryparser_set_last_runtime $clausewhere [lyrsql::quote $prt] ]
		}

		if { [dbinfo::is_mssql] } {
			regsub -all {\/\*currentdatetime\*\/.*?\/\*endcurrentdatetime\*\/} $clausewhere "/*currentdatetime*/CAST([lyrsql::quote [date::clockToSQLDateTime]] AS datetime)/*endcurrentdatetime*/" clausewhere
		} else {
			regsub -all {\/\*currentdatetime\*\/.*?\/\*endcurrentdatetime\*\/} $clausewhere "/*currentdatetime*/[lyrsql::quote [date::clockToSQLDateTime]]/*endcurrentdatetime*/" clausewhere
		}

		set kv_array(clausewhere_) $clausewhere

		set sql_parts [misc::segment_create_sql_from_kv kv_array]

		set sql [lindex $sql_parts 0]
		set count_statement [lindex $sql_parts 1]
		set html_statement [lindex $sql_parts 2]
		set html_count_statement [lindex $sql_parts 3]

		next_previous::set_default_max 20
		
		lmcgi::define_cookie segmenttesttable max 20
		lmcgi::define_cookie segmenttesttable skip 0
	
		set skip [ncgi::value skip]
		set max [ncgi::value max]
		
                set sql_error {}
		if {[catch { lyrsql::select $sql results [ncgi::value max] [ncgi::value skip] } msg]} {
                        set sql_error $msg
                } else {
                        # if we got an error, the results table will not be useful to look at
        		lmcgi::set_cookie segmenttesttable show_next $results(show_next)
        		lmcgi::set_cookie segmenttesttable show_prev $results(show_prev)
        		lmcgi::set_cookie segmenttesttable num_rows $results(num_rows)
                } 	

		if {[string length $sql_error] == 0} {
			set count [lyrsql::select_value $count_statement]
			set html [look::bread_crumbs "" 1 [lmcgi::page_url] "" "segmenttesttable" "$index_function_url" "viewsegments.html?search.html?~noresize~" 0 1]
			append html [scripts::updatebuttons]

		} else {
			set count 0
			set html [look::bread_crumbs "" 1 [lmcgi::page_url] "" "segmenttesttable" "$index_function_url" "viewsegments.html?search.html?~noresize~" 0 0]
		}

		append html [look::dialogbox_below_titlebox_begin]
		append html [subst {
				[text::hidden_fields count]
				[look::dialogbox_row "Segment name" $kv_array(name_)]
				[look::dialogbox_row "Description" $kv_array(desc_)]
				[look::dialogbox_row "Total" "$count"]
				[look::dialogbox_row "Your query"  "$kv_array(clausewhere_)"]
				[look::dialogbox_row "SQL query" "<font size=1>$sql</font>"]
		}]


		if {[string length $sql_error] > 0} {
                        # try to strip LM specific info from the error
                        regexp {(Database error information.+?)-+} $sql_error match parsed_sql_error
                        if {[string length $parsed_sql_error] == 0} {
                                # if the stripping effort failed, go back to the older method
                                regsub -nocase "TclProc_sqlexecute failed because SqlExecute threw a SqlClassException:" $sql_error "" parsed_sql_error
        			regsub -nocase "dbsqlexec.*failed" $parsed_sql_error "" parsed_sql_error
                        }
			append html [look::dialogbox_row "Error text" [look::light_table_border [string trim $parsed_sql_error]]]
		} 

		append html [look::dialogbox_below_titlebox_end]
		set dbMailList [lindex [array get results emailaddr_] 1]
		set emailList [list]
		foreach email $dbMailList {
		    if {[lsearch $emailList $email] == -1} {
			lappend emailList $email		    
		    } else {
			append html "<img src='/img/global/icon_exclamationmark-15x15.gif' alt='Warning'/> Your segment returns duplicate email addresses.  If you send a mailing to this segment, ListManager will automatically remove the duplicates so only one message will be sent per email address."
			break
		    }		    
		}
                append html "[look::dialogbox_buttons [subst {
				 [
				      	# figure out if we are editing a triggered mailing?
				       	if {[dbinfo::is_triggered_segment [lmcgi::value_int id [lmcgi::value_int key_field_value 0]]]} {
				   	    translation::button_href "Edit" "edit_triggered.tml?id=[lmcgi::value_int id]&sq=[ncgi::encode [ncgi::value sq ALL]]&viewtable_type=[ncgi::value viewtable_type all]" 
					} else {
					    translation::button_href "Edit" "edit.tml?id=[lmcgi::value_int id]&sq=[ncgi::encode [ncgi::value sq ALL]]&viewtable_type=[ncgi::value viewtable_type all]"
					}
				 ] 
				 [translation::button_href "Ok" "/segments/?sq=[ncgi::encode [ncgi::value sq ALL]]&viewtable_type=[ncgi::value viewtable_type all]"] 
		} ]]"
                if {[string length $sql_error] == 0} {
                    append html [look::viewtable_iframe_buttons_script "Test Segment" segmenttesttable "$index_function_url"]
                }

	}
	return $html
	
	
}

proc segments::choose_lists {} {
    if {[string length [lmcgi::button_pressed_list {"chosen_lists" "cancel"}]] > 0} {
        # finished with insert-field wizard, so go back to where we came from
        lmcgi::Doc_Post "/utilities/webforms/subscribe/index.tml"
    } 

    set tab_definitions {
        {
            "lists" 
            "NewSubscribeForm_ChooseLists.html"
            {
                set namelist {}
                set keylist {}
                
                # get the list of lists
                foreach list [lsort [security::what_lists_can_admin]] {
                    set key $list
                    set lists($key) $list
                }

                set existing_lists [split [ncgi::value subscribe_.Lists_] |]

                set selected_keys $existing_lists

                array set selectable_list {}
                array set selected_list {}
                foreach possible_list [array names lists] {
                    set this_key $lists($possible_list)
                    if {[lsearch $existing_lists $this_key] == -1} {
                        set selectable_list($possible_list) $lists($possible_list)
                    } else {
                        set selected_list($possible_list) $lists($possible_list)
                    }
                }
                
                # convert the final arrays into the structure needed by this chooser widget
                set selected_values {}
                foreach selected $selected_keys {
                    lappend selected_values $selected_list($selected)
                }
                
                set selectable_keys {}
                set selectable_values {}
                foreach selectable [lsort [array names selectable_list]] {
                    lappend selectable_keys $selectable
                    lappend selectable_values $selectable_list($selectable)
                }


                set id "lists"
                set leftLabel [translation::text "Available lists"]
                set leftNameList $selectable_keys
                set leftValueList $selectable_values
                set rightLabel [translation::text "Chosen lists"]
                set rightNameList $selected_keys
                set rightValueList $selected_values
                set length 8
                set minWidth 25
                append widget [javascript::makeSelectorWidget $id $leftLabel $leftValueList $leftNameList $rightLabel $rightValueList $rightNameList $length $minWidth ]
                append widget [javascript::get_selections_proc]
                append this_tab [look::dialogbox_row_centered $widget]
                #append this_tab [lmcgi::nvlist_table]
            }
        }
    }

    set fields_and_defaults ""

    # the name of the table that we'll be reading from and writing to
    set table_name ""

    # the name of the primary key field
    set key_field_name ""

    # the URL to send the user once they've finished with this builder
    set end_url ""

    # the general section in this application this builder is in, so that message pages
    # can be displayed with the right highlighted tab
    set section "utilties"

    # the names of any read-only fields, that are to be preserved in hidden fields. Usually,
    # these all have default values that the user then can't change, but sometimes is allowed
    # to see.
    set read_only_fields {}

    append html [look::save_edit_load $table_name $key_field_name $fields_and_defaults $end_url $section $read_only_fields $tab_definitions]
    
    # call the save/edit/load function, and return the HTML it creates
    append html [look::dialogbox_buttons "<input [translation::inputTagSubmitImage "Ok" {onClick="getSelections(this.form)"}] name=\"chosen_lists\"> <input [translation::inputTagSubmitImage Cancel] name=\"cancel\">" ]
    return $html
}

proc segments::choose_preferences {} {
    if {[string length [lmcgi::button_pressed_list {"chosen_preferences" "cancel-recipients"}]] > 0} {
    # finished with insert-field wizard, so go back to where we came from
    lmcgi::Doc_Post "/segments/[ncgi::value page].tml"
    }

    set tab_definitions {
    {
        "Preferences" 
        "preferences__choose_preferences.html"
        {
        set namelist {}
        set keylist {}

        # get the list of preferences
        array set results {}                    
        array unset results

            #foreach list [lsort [security::what_lists_can_admin]] {
            #set key "$list: all"
            #set segments($key) "0|$list"
            #array unset results

            # query to bring in the preference sections
            lyrsql::select "Select preference_area,preference_area_id from vw_lyris_preferences" results

                    #puts "looking for segments in list: $list"
            
            # parse out the values and put into this_id and this_name array and then put
            # into a preference array
            for {set row 0} {$row < $results(num_rows)} {incr row} {
            set this_id [lindex $results(preference_area_id) $row]
            #set this_list [lindex $results(list_) $row]
            set this_name [lindex $results(preference_area) $row]
            #puts "found segment: $this_name"
            #set key "$this_list: $this_name"
            #set segments($key) $this_id
            set preferences($this_name) $this_id
            }
        #}

        # parse out the existing preference values and put selected and selectable structures
        set existing_preferences [ncgi::value subsets_.Preferences_]
        array set selectable_preference {}
        array set selected_preference {}
        foreach possible_preference [array names preferences] {
            set this_key $preferences($possible_preference)
            if {[lsearch $existing_preferences $this_key] == -1} {
            set selectable_preference($possible_preference) $preferences($possible_preference)
            } else {
            set selected_preference($possible_preference) $preferences($possible_preference)
            }
        }
                
        # convert the final arrays into the structure needed by this chooser widget
        set selected_keys {}
        set selected_values {}
        foreach selected [lsort [array names selected_preference]] {
            lappend selected_keys $selected
            lappend selected_values $selected_preference($selected)
        }
                
        set selectable_keys {}
        set selectable_values {}
        foreach selectable [lsort [array names selectable_preference]] {
            lappend selectable_keys $selectable
            lappend selectable_values $selectable_preference($selectable)
        }


        # set the id that will later used to parse out the javascript cgi values
        set id "preferences"
        set leftLabel [translation::text "Available Preference"]
        set leftNameList $selectable_keys
        set leftValueList $selectable_values
        set rightLabel [translation::text "Chosen Preference"]
        set rightNameList $selected_keys
        set rightValueList $selected_values
        set length 8
        set minWidth 25
        append widget [javascript::makeSelectorWidget $id $leftLabel $leftValueList $leftNameList $rightLabel $rightValueList $rightNameList $length $minWidth ]
                if {![security::pro_segments_allowed]} {
                    regsub "<select name=left$id multiple size" $widget "<select name=\"left$id\" mulitiple disabled size" widget   
                }
                append widget [javascript::get_selections_proc]
                if {![security::pro_segments_allowed]} {
                    regsub "<select name=right$id multiple size" $widget "<select name=\"right$id\" mulitiple disabled size" widget   
                }
                append this_tab [look::dialogbox_row_centered $widget]
        #append this_tab [lmcgi::nvlist_table]
        }
    }
    }

    set fields_and_defaults ""

    # the name of the table that we'll be reading from and writing to
    set table_name ""

    # the name of the primary key field
    set key_field_name ""

    # the URL to send the user once they've finished with this builder
    set end_url ""

    # the general section in this application this builder is in, so that message pages
    # can be displayed with the right highlighted tab
    set section "content"

    # the names of any read-only fields, that are to be preserved in hidden fields. Usually,
    # these all have default values that the user then can't change, but sometimes is allowed
    # to see.
    set read_only_fields {}

    # call the save/edit/load function, and return the HTML it creates
    append html  [look::save_edit_load $table_name $key_field_name $fields_and_defaults $end_url $section $read_only_fields $tab_definitions]
    if {[security::pro_segments_allowed]} {
        append html [look::dialogbox_buttons "<input [translation::inputTagSubmitImage "Ok" {onClick="getSelections(this.form)"}] name=\"chosen_preferences\"> <input [translation::inputTagSubmitImage Cancel] name=\"cancel-recipients\">" ]
    } else {
        append html [look::dialogbox_buttons "<font [htmltag::font_face] size=1>[security::pro_segments_disclaimer]</font>&nbsp;&nbsp;&nbsp;<input [translation::inputTagSubmitImage Cancel] name=\"cancel-recipients\">" ]
    }
    return $html
}

proc segments::choose_selections {} {
    if {[string length [lmcgi::button_pressed_list {"chosen_selections" "cancel-recipients"}]] > 0} {
    # finished with insert-field wizard, so go back to where we came from
    lmcgi::Doc_Post "/segments/[ncgi::value page].tml"
    }

    set tab_definitions {
    {
        "Selections" 
        "selctions__choose_selections.html"
        {
        set namelist {}
        set keylist {}

        # get the list of preferences
        array set results {}                    
        array unset results

            #foreach list [lsort [security::what_lists_can_admin]] {
            #set key "$list: all"
            #set segments($key) "0|$list"
            #array unset results

            # query to bring in the selections sections
            set linkedDBServer "loopback"
            set linkedProcName "wolters102b.dbo.proc_lyris_value_list"
            set selectionParameter [ncgi::value custom.CriteriaSelection_]
            set sql "select display, display_id from openquery($linkedDBServer,'SET FMTONLY OFF exec $linkedProcName $selectionParameter')"
            #lyrsql::select "Select preference_area,preference_area_id from vw_lyris_preferences" results
            lyrsql::select $sql results

                    #puts "looking for segments in list: $list"
            
            # parse out the values and put into this_id and this_name array and then put
            # into a preference array
            for {set row 0} {$row < $results(num_rows)} {incr row} {
            set this_id [lindex $results(display_id) $row]
            #set this_list [lindex $results(list_) $row]
            set this_name [lindex $results(display) $row]
            #puts "found segment: $this_name"
            #set key "$this_list: $this_name"
            #set segments($key) $this_id
            set preferences($this_name) $this_id
            }
        #}

        # parse out the existing preference values and put selected and selectable structures
        set existing_preferences [ncgi::value subsets_.Preferences_]
        array set selectable_preference {}
        array set selected_preference {}
        foreach possible_preference [array names preferences] {
            set this_key $preferences($possible_preference)
            if {[lsearch $existing_preferences $this_key] == -1} {
            set selectable_preference($possible_preference) $preferences($possible_preference)
            } else {
            set selected_preference($possible_preference) $preferences($possible_preference)
            }
        }
                
        # convert the final arrays into the structure needed by this chooser widget
        set selected_keys {}
        set selected_values {}
        foreach selected [lsort [array names selected_preference]] {
            lappend selected_keys $selected
            lappend selected_values $selected_preference($selected)
        }
                
        set selectable_keys {}
        set selectable_values {}
        foreach selectable [lsort [array names selectable_preference]] {
            lappend selectable_keys $selectable
            lappend selectable_values $selectable_preference($selectable)
        }


        # set the id that will later used to parse out the javascript cgi values
        set id "selections"
        set leftLabel [translation::text "Available Preference"]
        set leftNameList $selectable_keys
        set leftValueList $selectable_values
        set rightLabel [translation::text "Chosen Preference"]
        set rightNameList $selected_keys
        set rightValueList $selected_values
        set length 8
        set minWidth 25
        append widget [javascript::makeSelectorWidget $id $leftLabel $leftValueList $leftNameList $rightLabel $rightValueList $rightNameList $length $minWidth ]
                if {![security::pro_segments_allowed]} {
                    regsub "<select name=left$id multiple size" $widget "<select name=\"left$id\" mulitiple disabled size" widget   
                }
                append widget [javascript::get_selections_proc]
                if {![security::pro_segments_allowed]} {
                    regsub "<select name=right$id multiple size" $widget "<select name=\"right$id\" mulitiple disabled size" widget   
                }
                append this_tab [look::dialogbox_row_centered $widget]
        #append this_tab [lmcgi::nvlist_table]
        }
    }
    }

    set fields_and_defaults ""

    # the name of the table that we'll be reading from and writing to
    set table_name ""

    # the name of the primary key field
    set key_field_name ""

    # the URL to send the user once they've finished with this builder
    set end_url ""

    # the general section in this application this builder is in, so that message pages
    # can be displayed with the right highlighted tab
    set section "content"

    # the names of any read-only fields, that are to be preserved in hidden fields. Usually,
    # these all have default values that the user then can't change, but sometimes is allowed
    # to see.
    set read_only_fields {}

    # call the save/edit/load function, and return the HTML it creates
    append html  [look::save_edit_load $table_name $key_field_name $fields_and_defaults $end_url $section $read_only_fields $tab_definitions]
    if {[security::pro_segments_allowed]} {
        append html [look::dialogbox_buttons "<input [translation::inputTagSubmitImage "Ok" {onClick="getSelections(this.form)"}] name=\"chosen_selections\"> <input [translation::inputTagSubmitImage Cancel] name=\"cancel-recipients\">" ]
    } else {
        append html [look::dialogbox_buttons "<font [htmltag::font_face] size=1>[security::pro_segments_disclaimer]</font>&nbsp;&nbsp;&nbsp;<input [translation::inputTagSubmitImage Cancel] name=\"cancel-recipients\">" ]
    }
    return $html
}

proc segments::choose_date {} {
    if {[string length [lmcgi::button_pressed_list {"chosen_dates" "cancel-recipients"}]] > 0} {
    # finished with insert-field wizard, so go back to where we came from
    lmcgi::Doc_Post "/segments/[ncgi::value page].tml"
    }

    set tab_definitions {
    {
        "Date" 
        "dates__choose_dates.html"
        {
append this_tab [look::dialogbox_row_span "<table cellpadding=\"0\" cellspacing=\"0\"><tr><td><h1>Please enter in your Start and End Dates to query</h1></td></tr></table>"] 
append this_tab [look::dialogbox_row_fillout_datetime "Start Date" "custom.StartDate_" 19 19 {is_sql_date} "&nbsp;<font [htmltag::font_face] size=\"1\"><i>yyyy-mm-dd hh:mm:ss</i></font>"]
append this_tab [look::dialogbox_row_fillout_datetime "End Date" "custom.EndDate_" 19 19 {is_sql_date} "&nbsp;<font [htmltag::font_face] size=\"1\"><i>yyyy-mm-dd hh:mm:ss</i></font>"]
        #append this_tab [look::dialogbox_row_centered $widget]
        #append this_tab [lmcgi::nvlist_table]
        }
    }
    }

    set fields_and_defaults ""

    # the name of the table that we'll be reading from and writing to
    set table_name ""

    # the name of the primary key field
    set key_field_name ""

    # the URL to send the user once they've finished with this builder
    set end_url ""

    # the general section in this application this builder is in, so that message pages
    # can be displayed with the right highlighted tab
    set section "content"

    # the names of any read-only fields, that are to be preserved in hidden fields. Usually,
    # these all have default values that the user then can't change, but sometimes is allowed
    # to see.
    set read_only_fields {}

    # call the save/edit/load function, and return the HTML it creates
    append html  [look::save_edit_load $table_name $key_field_name $fields_and_defaults $end_url $section $read_only_fields $tab_definitions]
    if {[security::pro_segments_allowed]} {
        append html [look::dialogbox_buttons "<input [translation::inputTagSubmitImage "Ok" {onClick="getSelections(this.form)"}] name=\"chosen_dates\"> <input [translation::inputTagSubmitImage Cancel] name=\"cancel-recipients\">" ]
    } else {
        append html [look::dialogbox_buttons "<font [htmltag::font_face] size=1>[security::pro_segments_disclaimer]</font>&nbsp;&nbsp;&nbsp;<input [translation::inputTagSubmitImage Cancel] name=\"cancel-recipients\">" ]
    }
    return $html
}

proc segments::choose_text {} {
    if {[string length [lmcgi::button_pressed_list {"chosen_text" "cancel-recipients"}]] > 0} {
    # finished with insert-field wizard, so go back to where we came from
    lmcgi::Doc_Post "/segments/[ncgi::value page].tml"
    }

    set tab_definitions {
    {
        "Date" 
        "dates__choose_dates.html"
        {
append this_tab [look::dialogbox_row_span "<table cellpadding=\"0\" cellspacing=\"0\"><tr><td><h1>Enter Product Numbers, seperated by commas</h1></td></tr></table>"] 
append this_tab [look::dialogbox_row_fillout_line "Product Numbers" custom.InputText_ 100 255]
        #append this_tab [look::dialogbox_row_centered $widget]
        #append this_tab [lmcgi::nvlist_table]
        }
    }
    }

    set fields_and_defaults ""

    # the name of the table that we'll be reading from and writing to
    set table_name ""

    # the name of the primary key field
    set key_field_name ""

    # the URL to send the user once they've finished with this builder
    set end_url ""

    # the general section in this application this builder is in, so that message pages
    # can be displayed with the right highlighted tab
    set section "content"

    # the names of any read-only fields, that are to be preserved in hidden fields. Usually,
    # these all have default values that the user then can't change, but sometimes is allowed
    # to see.
    set read_only_fields {}

    # call the save/edit/load function, and return the HTML it creates
    append html  [look::save_edit_load $table_name $key_field_name $fields_and_defaults $end_url $section $read_only_fields $tab_definitions]
    if {[security::pro_segments_allowed]} {
        append html [look::dialogbox_buttons "<input [translation::inputTagSubmitImage "Ok" {onClick="getSelections(this.form)"}] name=\"chosen_text\"> <input [translation::inputTagSubmitImage Cancel] name=\"cancel-recipients\">" ]
    } else {
        append html [look::dialogbox_buttons "<font [htmltag::font_face] size=1>[security::pro_segments_disclaimer]</font>&nbsp;&nbsp;&nbsp;<input [translation::inputTagSubmitImage Cancel] name=\"cancel-recipients\">" ]
    }
    return $html
}